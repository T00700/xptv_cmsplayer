class Lodash{static name="Lodash";static version="1.2.2";static about(){return console.log(`\n🟧 ${this.name} v${this.version}\n`)}static get(object={},path="",defaultValue=undefined){if(!Array.isArray(path))path=this.toPath(path);const result=path.reduce((previousValue,currentValue)=>{return Object(previousValue)[currentValue]},object);return result===undefined?defaultValue:result}static set(object={},path="",value){if(!Array.isArray(path))path=this.toPath(path);path.slice(0,-1).reduce((previousValue,currentValue,currentIndex)=>Object(previousValue[currentValue])===previousValue[currentValue]?previousValue[currentValue]:previousValue[currentValue]=/^\d+$/.test(path[currentIndex+1])?[]:{},object)[path[path.length-1]]=value;return object}static unset(object={},path=""){if(!Array.isArray(path))path=this.toPath(path);let result=path.reduce((previousValue,currentValue,currentIndex)=>{if(currentIndex===path.length-1){delete previousValue[currentValue];return true}return Object(previousValue)[currentValue]},object);return result}static toPath(value){return value.replace(/\[(\d+)\]/g,".$1").split(".").filter(Boolean)}static escape(string){const map={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"};return string.replace(/[&<>"']/g,m=>map[m])}static unescape(string){const map={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"};return string.replace(/&amp;|&lt;|&gt;|&quot;|&#39;/g,m=>map[m])}}class $Storage{static name="$Storage";static version="1.0.9";static about(){return console.log(`\n🟧 ${this.name} v${this.version}\n`)}static data=null;static dataFile="box.dat";static#nameRegex=/^@(?<key>[^.]+)(?:\.(?<path>.*))?$/;static#platform(){if("undefined"!==typeof $environment&&$environment["surge-version"])return"Surge";if("undefined"!==typeof $environment&&$environment["stash-version"])return"Stash";if("undefined"!==typeof module&&!!module.exports)return"Node.js";if("undefined"!==typeof $task)return"Quantumult X";if("undefined"!==typeof $loon)return"Loon";if("undefined"!==typeof $rocket)return"Shadowrocket";if("undefined"!==typeof Egern)return"Egern"}static getItem(keyName=new String,defaultValue=null){let keyValue=defaultValue;switch(keyName.startsWith("@")){case true:const{key,path}=keyName.match(this.#nameRegex)?.groups;keyName=key;let value=this.getItem(keyName,{});if(typeof value!=="object")value={};keyValue=Lodash.get(value,path);try{keyValue=JSON.parse(keyValue)}catch(e){}break;default:switch(this.#platform()){case"Surge":case"Loon":case"Stash":case"Egern":case"Shadowrocket":keyValue=$persistentStore.read(keyName);break;case"Quantumult X":keyValue=$prefs.valueForKey(keyName);break;case"Node.js":this.data=this.#loaddata(this.dataFile);keyValue=this.data?.[keyName];break;default:keyValue=this.data?.[keyName]||null;break}try{keyValue=JSON.parse(keyValue)}catch(e){}break}return keyValue??defaultValue}static setItem(keyName=new String,keyValue=new String){let result=false;switch(typeof keyValue){case"object":keyValue=JSON.stringify(keyValue);break;default:keyValue=String(keyValue);break}switch(keyName.startsWith("@")){case true:const{key,path}=keyName.match(this.#nameRegex)?.groups;keyName=key;let value=this.getItem(keyName,{});if(typeof value!=="object")value={};Lodash.set(value,path,keyValue);result=this.setItem(keyName,value);break;default:switch(this.#platform()){case"Surge":case"Loon":case"Stash":case"Egern":case"Shadowrocket":result=$persistentStore.write(keyValue,keyName);break;case"Quantumult X":result=$prefs.setValueForKey(keyValue,keyName);break;case"Node.js":this.data=this.#loaddata(this.dataFile);this.data[keyName]=keyValue;this.#writedata(this.dataFile);result=true;break;default:result=this.data?.[keyName]||null;break}break}return result}static removeItem(keyName){let result=false;switch(keyName.startsWith("@")){case true:const{key,path}=keyName.match(this.#nameRegex)?.groups;keyName=key;let value=this.getItem(keyName);if(typeof value!=="object")value={};keyValue=Lodash.unset(value,path);result=this.setItem(keyName,value);break;default:switch(this.#platform()){case"Surge":case"Loon":case"Stash":case"Egern":case"Shadowrocket":result=false;break;case"Quantumult X":result=$prefs.removeValueForKey(keyName);break;case"Node.js":result=false;break;default:result=false;break}break}return result}static clear(){let result=false;switch(this.#platform()){case"Surge":case"Loon":case"Stash":case"Egern":case"Shadowrocket":result=false;break;case"Quantumult X":result=$prefs.removeAllValues();break;case"Node.js":result=false;break;default:result=false;break}return result}static#loaddata(dataFile){if(this.isNode()){this.fs=this.fs?this.fs:require("fs");this.path=this.path?this.path:require("path");const curDirDataFilePath=this.path.resolve(dataFile);const rootDirDataFilePath=this.path.resolve(process.cwd(),dataFile);const isCurDirDataFile=this.fs.existsSync(curDirDataFilePath);const isRootDirDataFile=!isCurDirDataFile&&this.fs.existsSync(rootDirDataFilePath);if(isCurDirDataFile||isRootDirDataFile){const datPath=isCurDirDataFile?curDirDataFilePath:rootDirDataFilePath;try{return JSON.parse(this.fs.readFileSync(datPath))}catch(e){return{}}}else return{}}else return{}}static#writedata(dataFile=this.dataFile){if(this.isNode()){this.fs=this.fs?this.fs:require("fs");this.path=this.path?this.path:require("path");const curDirDataFilePath=this.path.resolve(dataFile);const rootDirDataFilePath=this.path.resolve(process.cwd(),dataFile);const isCurDirDataFile=this.fs.existsSync(curDirDataFilePath);const isRootDirDataFile=!isCurDirDataFile&&this.fs.existsSync(rootDirDataFilePath);const jsondata=JSON.stringify(this.data);if(isCurDirDataFile){this.fs.writeFileSync(curDirDataFilePath,jsondata)}else if(isRootDirDataFile){this.fs.writeFileSync(rootDirDataFilePath,jsondata)}else{this.fs.writeFileSync(curDirDataFilePath,jsondata)}}}}class ENV{static name="ENV";static version="1.8.3";static about(){return console.log(`\n🟧 ${this.name} v${this.version}\n`)}constructor(name,opts){console.log(`\n🟧 ${ENV.name} v${ENV.version}\n`);this.name=name;this.logs=[];this.isMute=false;this.isMuteLog=false;this.logSeparator="\n";this.encoding="utf-8";this.startTime=(new Date).getTime();Object.assign(this,opts);this.log(`\n🚩 开始!\n${name}\n`)}environment(){switch(this.platform()){case"Surge":$environment.app="Surge";return $environment;case"Stash":$environment.app="Stash";return $environment;case"Egern":$environment.app="Egern";return $environment;case"Loon":let environment=$loon.split(" ");return{device:environment[0],ios:environment[1],"loon-version":environment[2],app:"Loon"};case"Quantumult X":return{app:"Quantumult X"};case"Node.js":process.env.app="Node.js";return process.env;default:return{}}}platform(){if("undefined"!==typeof $environment&&$environment["surge-version"])return"Surge";if("undefined"!==typeof $environment&&$environment["stash-version"])return"Stash";if("undefined"!==typeof module&&!!module.exports)return"Node.js";if("undefined"!==typeof $task)return"Quantumult X";if("undefined"!==typeof $loon)return"Loon";if("undefined"!==typeof $rocket)return"Shadowrocket";if("undefined"!==typeof Egern)return"Egern"}isNode(){return"Node.js"===this.platform()}isQuanX(){return"Quantumult X"===this.platform()}isSurge(){return"Surge"===this.platform()}isLoon(){return"Loon"===this.platform()}isShadowrocket(){return"Shadowrocket"===this.platform()}isStash(){return"Stash"===this.platform()}isEgern(){return"Egern"===this.platform()}async getScript(url){return await this.fetch(url).then(response=>response.body)}async runScript(script,runOpts){let httpapi=$Storage.getItem("@chavy_boxjs_userCfgs.httpapi");httpapi=httpapi?.replace?.(/\n/g,"")?.trim();let httpapi_timeout=$Storage.getItem("@chavy_boxjs_userCfgs.httpapi_timeout");httpapi_timeout=httpapi_timeout*1??20;httpapi_timeout=runOpts?.timeout??httpapi_timeout;const[password,address]=httpapi.split("@");const request={url:`http://${address}/v1/scripting/evaluate`,body:{script_text:script,mock_type:"cron",timeout:httpapi_timeout},headers:{"X-Key":password,Accept:"*/*"},timeout:httpapi_timeout};await this.fetch(request).then(response=>response.body,error=>this.logErr(error))}initGotEnv(opts){this.got=this.got?this.got:require("got");this.cktough=this.cktough?this.cktough:require("tough-cookie");this.ckjar=this.ckjar?this.ckjar:new this.cktough.CookieJar;if(opts){opts.headers=opts.headers?opts.headers:{};if(undefined===opts.headers.Cookie&&undefined===opts.cookieJar){opts.cookieJar=this.ckjar}}}async fetch(request={}||"",option={}){switch(request.constructor){case Object:request={...option,...request};break;case String:request={...option,url:request};break}if(!request.method){request.method="GET";if(request.body??request.bodyBytes)request.method="POST"}delete request.headers?.Host;delete request.headers?.[":authority"];delete request.headers?.["Content-Length"];delete request.headers?.["content-length"];const method=request.method.toLocaleLowerCase();switch(this.platform()){case"Loon":case"Surge":case"Stash":case"Egern":case"Shadowrocket":default:if(request.timeout){request.timeout=parseInt(request.timeout,10);if(this.isSurge());else request.timeout=request.timeout*1e3}if(request.policy){if(this.isLoon())request.node=request.policy;if(this.isStash())Lodash.set(request,"headers.X-Stash-Selected-Proxy",encodeURI(request.policy));if(this.isShadowrocket())Lodash.set(request,"headers.X-Surge-Proxy",request.policy)}if(typeof request.redirection==="boolean")request["auto-redirect"]=request.redirection;if(request.bodyBytes&&!request.body){request.body=request.bodyBytes;delete request.bodyBytes}return await new Promise((resolve,reject)=>{$httpClient[method](request,(error,response,body)=>{if(error)reject(error);else{response.ok=/^2\d\d$/.test(response.status);response.statusCode=response.status;if(body){response.body=body;if(request["binary-mode"]==true)response.bodyBytes=body}resolve(response)}})});case"Quantumult X":if(request.policy)Lodash.set(request,"opts.policy",request.policy);if(typeof request["auto-redirect"]==="boolean")Lodash.set(request,"opts.redirection",request["auto-redirect"]);if(request.body instanceof ArrayBuffer){request.bodyBytes=request.body;delete request.body}else if(ArrayBuffer.isView(request.body)){request.bodyBytes=request.body.buffer.slice(request.body.byteOffset,request.body.byteLength+request.body.byteOffset);delete object.body}else if(request.body)delete request.bodyBytes;return await $task.fetch(request).then(response=>{response.ok=/^2\d\d$/.test(response.statusCode);response.status=response.statusCode;return response},reason=>Promise.reject(reason.error));case"Node.js":let iconv=require("iconv-lite");this.initGotEnv(request);const{url,...option}=request;return await this.got[method](url,option).on("redirect",(response,nextOpts)=>{try{if(response.headers["set-cookie"]){const ck=response.headers["set-cookie"].map(this.cktough.Cookie.parse).toString();if(ck){this.ckjar.setCookieSync(ck,null)}nextOpts.cookieJar=this.ckjar}}catch(e){this.logErr(e)}}).then(response=>{response.statusCode=response.status;response.body=iconv.decode(response.rawBody,this.encoding);response.bodyBytes=response.rawBody;return response},error=>Promise.reject(error.message))}}time(format,ts=null){const date=ts?new Date(ts):new Date;let o={"M+":date.getMonth()+1,"d+":date.getDate(),"H+":date.getHours(),"m+":date.getMinutes(),"s+":date.getSeconds(),"q+":Math.floor((date.getMonth()+3)/3),S:date.getMilliseconds()};if(/(y+)/.test(format))format=format.replace(RegExp.$1,(date.getFullYear()+"").substr(4-RegExp.$1.length));for(let k in o)if(new RegExp("("+k+")").test(format))format=format.replace(RegExp.$1,RegExp.$1.length==1?o[k]:("00"+o[k]).substr((""+o[k]).length));return format}msg(title=name,subt="",desc="",opts){const toEnvOpts=rawopts=>{switch(typeof rawopts){case undefined:return rawopts;case"string":switch(this.platform()){case"Surge":case"Stash":case"Egern":default:return{url:rawopts};case"Loon":case"Shadowrocket":return rawopts;case"Quantumult X":return{"open-url":rawopts};case"Node.js":return undefined}case"object":switch(this.platform()){case"Surge":case"Stash":case"Egern":case"Shadowrocket":default:{let openUrl=rawopts.url||rawopts.openUrl||rawopts["open-url"];return{url:openUrl}}case"Loon":{let openUrl=rawopts.openUrl||rawopts.url||rawopts["open-url"];let mediaUrl=rawopts.mediaUrl||rawopts["media-url"];return{openUrl:openUrl,mediaUrl:mediaUrl}}case"Quantumult X":{let openUrl=rawopts["open-url"]||rawopts.url||rawopts.openUrl;let mediaUrl=rawopts["media-url"]||rawopts.mediaUrl;let updatePasteboard=rawopts["update-pasteboard"]||rawopts.updatePasteboard;return{"open-url":openUrl,"media-url":mediaUrl,"update-pasteboard":updatePasteboard}}case"Node.js":return undefined}default:return undefined}};if(!this.isMute){switch(this.platform()){case"Surge":case"Loon":case"Stash":case"Egern":case"Shadowrocket":default:$notification.post(title,subt,desc,toEnvOpts(opts));break;case"Quantumult X":$notify(title,subt,desc,toEnvOpts(opts));break;case"Node.js":break}}if(!this.isMuteLog){let logs=["","==============📣系统通知📣=============="];logs.push(title);subt?logs.push(subt):"";desc?logs.push(desc):"";console.log(logs.join("\n"));this.logs=this.logs.concat(logs)}}log(...logs){if(logs.length>0){this.logs=[...this.logs,...logs]}console.log(logs.join(this.logSeparator))}logErr(error){switch(this.platform()){case"Surge":case"Loon":case"Stash":case"Egern":case"Shadowrocket":case"Quantumult X":default:this.log("",`❗️ ${this.name}, 错误!`,error);break;case"Node.js":this.log("",`❗️${this.name}, 错误!`,error.stack);break}}wait(time){return new Promise(resolve=>setTimeout(resolve,time))}done(object={}){const endTime=(new Date).getTime();const costTime=(endTime-this.startTime)/1e3;this.log("",`🚩 ${this.name}, 结束! 🕛 ${costTime} 秒`,"");switch(this.platform()){case"Surge":if(object.policy)Lodash.set(object,"headers.X-Surge-Policy",object.policy);$done(object);break;case"Loon":if(object.policy)object.node=object.policy;$done(object);break;case"Stash":if(object.policy)Lodash.set(object,"headers.X-Stash-Selected-Proxy",encodeURI(object.policy));$done(object);break;case"Egern":$done(object);break;case"Shadowrocket":default:$done(object);break;case"Quantumult X":if(object.policy)Lodash.set(object,"opts.policy",object.policy);delete object["auto-redirect"];delete object["auto-cookie"];delete object["binary-mode"];delete object.charset;delete object.host;delete object.insecure;delete object.method;delete object.opt;delete object.path;delete object.policy;delete object["policy-descriptor"];delete object.scheme;delete object.sessionIndex;delete object.statusCode;delete object.timeout;if(object.body instanceof ArrayBuffer){object.bodyBytes=object.body;delete object.body}else if(ArrayBuffer.isView(object.body)){object.bodyBytes=object.body.buffer.slice(object.body.byteOffset,object.body.byteLength+object.body.byteOffset);delete object.body}else if(object.body)delete object.bodyBytes;$done(object);break;case"Node.js":process.exit(1);break}}}var Settings$1={Switch:true};var Default={Settings:Settings$1};var Default$1=Object.freeze({__proto__:null,Settings:Settings$1,"default":Default});var Settings={Switch:true,Detail:{splash:true,feed:true,activity:false,story:true,cinema:true,view:true,search:true,xlive:true,Hot_search:true,Hot_topics:true,Most_visited:true,Dynamic_adcard:true}};var BiliBili_ADBlock={Settings:Settings};var Global=Object.freeze({__proto__:null,Settings:Settings,"default":BiliBili_ADBlock});var Database$1=Database={Default:Default$1,ADBlock:Global};function getStorage(key,names,database){let BoxJs=$Storage.getItem(key,database);let Argument={};if(typeof $argument!=="undefined"){if(Boolean($argument)){let arg=Object.fromEntries($argument.split("&").map(item=>item.split("=").map(i=>i.replace(/\"/g,""))));for(let item in arg)Lodash.set(Argument,item,arg[item])}}const Store={Settings:database?.Default?.Settings||{},Configs:database?.Default?.Configs||{},Caches:{}};if(!Array.isArray(names))names=[names];for(let name of names){Store.Settings={...Store.Settings,...database?.[name]?.Settings,...Argument,...BoxJs?.[name]?.Settings};Store.Configs={...Store.Configs,...database?.[name]?.Configs};if(BoxJs?.[name]?.Caches&&typeof BoxJs?.[name]?.Caches==="string")BoxJs[name].Caches=JSON.parse(BoxJs?.[name]?.Caches);Store.Caches={...Store.Caches,...BoxJs?.[name]?.Caches}}traverseObject(Store.Settings,(key,value)=>{if(value==="true"||value==="false")value=JSON.parse(value);else if(typeof value==="string"){if(value.includes(","))value=value.split(",").map(item=>string2number(item));else value=string2number(value)}return value});return Store;function traverseObject(o,c){for(var t in o){var n=o[t];o[t]="object"==typeof n&&null!==n?traverseObject(n,c):c(t,n)}return o}function string2number(string){if(string&&!isNaN(string))string=parseInt(string,10);return string}}function setENV(name,platforms,database){console.log(`☑️ Set Environment Variables`,"");let{Settings,Caches,Configs}=getStorage(name,platforms,database);if(!Array.isArray(Settings?.Locales))Settings.Locales=Settings.Locales?[Settings.Locales]:[];console.log(`✅ Set Environment Variables, Settings: ${typeof Settings}, Settings内容: ${JSON.stringify(Settings)}`,"");return{Settings:Settings,Caches:Caches,Configs:Configs}}const Z_FIXED$1=4;const Z_BINARY=0;const Z_TEXT=1;const Z_UNKNOWN$1=2;function zero$1(buf){let len=buf.length;while(--len>=0){buf[len]=0}}const STORED_BLOCK=0;const STATIC_TREES=1;const DYN_TREES=2;const MIN_MATCH$1=3;const MAX_MATCH$1=258;const LENGTH_CODES$1=29;const LITERALS$1=256;const L_CODES$1=LITERALS$1+1+LENGTH_CODES$1;const D_CODES$1=30;const BL_CODES$1=19;const HEAP_SIZE$1=2*L_CODES$1+1;const MAX_BITS$1=15;const Buf_size=16;const MAX_BL_BITS=7;const END_BLOCK=256;const REP_3_6=16;const REPZ_3_10=17;const REPZ_11_138=18;const extra_lbits=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);const extra_dbits=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);const extra_blbits=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);const bl_order=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);const DIST_CODE_LEN=512;const static_ltree=new Array((L_CODES$1+2)*2);zero$1(static_ltree);const static_dtree=new Array(D_CODES$1*2);zero$1(static_dtree);const _dist_code=new Array(DIST_CODE_LEN);zero$1(_dist_code);const _length_code=new Array(MAX_MATCH$1-MIN_MATCH$1+1);zero$1(_length_code);const base_length=new Array(LENGTH_CODES$1);zero$1(base_length);const base_dist=new Array(D_CODES$1);zero$1(base_dist);function StaticTreeDesc(static_tree,extra_bits,extra_base,elems,max_length){this.static_tree=static_tree;this.extra_bits=extra_bits;this.extra_base=extra_base;this.elems=elems;this.max_length=max_length;this.has_stree=static_tree&&static_tree.length}let static_l_desc;let static_d_desc;let static_bl_desc;function TreeDesc(dyn_tree,stat_desc){this.dyn_tree=dyn_tree;this.max_code=0;this.stat_desc=stat_desc}const d_code=dist=>{return dist<256?_dist_code[dist]:_dist_code[256+(dist>>>7)]};const put_short=(s,w)=>{s.pending_buf[s.pending++]=w&255;s.pending_buf[s.pending++]=w>>>8&255};const send_bits=(s,value,length)=>{if(s.bi_valid>Buf_size-length){s.bi_buf|=value<<s.bi_valid&65535;put_short(s,s.bi_buf);s.bi_buf=value>>Buf_size-s.bi_valid;s.bi_valid+=length-Buf_size}else{s.bi_buf|=value<<s.bi_valid&65535;s.bi_valid+=length}};const send_code=(s,c,tree)=>{send_bits(s,tree[c*2],tree[c*2+1])};const bi_reverse=(code,len)=>{let res=0;do{res|=code&1;code>>>=1;res<<=1}while(--len>0);return res>>>1};const bi_flush=s=>{if(s.bi_valid===16){put_short(s,s.bi_buf);s.bi_buf=0;s.bi_valid=0}else if(s.bi_valid>=8){s.pending_buf[s.pending++]=s.bi_buf&255;s.bi_buf>>=8;s.bi_valid-=8}};const gen_bitlen=(s,desc)=>{const tree=desc.dyn_tree;const max_code=desc.max_code;const stree=desc.stat_desc.static_tree;const has_stree=desc.stat_desc.has_stree;const extra=desc.stat_desc.extra_bits;const base=desc.stat_desc.extra_base;const max_length=desc.stat_desc.max_length;let h;let n,m;let bits;let xbits;let f;let overflow=0;for(bits=0;bits<=MAX_BITS$1;bits++){s.bl_count[bits]=0}tree[s.heap[s.heap_max]*2+1]=0;for(h=s.heap_max+1;h<HEAP_SIZE$1;h++){n=s.heap[h];bits=tree[tree[n*2+1]*2+1]+1;if(bits>max_length){bits=max_length;overflow++}tree[n*2+1]=bits;if(n>max_code){continue}s.bl_count[bits]++;xbits=0;if(n>=base){xbits=extra[n-base]}f=tree[n*2];s.opt_len+=f*(bits+xbits);if(has_stree){s.static_len+=f*(stree[n*2+1]+xbits)}}if(overflow===0){return}do{bits=max_length-1;while(s.bl_count[bits]===0){bits--}s.bl_count[bits]--;s.bl_count[bits+1]+=2;s.bl_count[max_length]--;overflow-=2}while(overflow>0);for(bits=max_length;bits!==0;bits--){n=s.bl_count[bits];while(n!==0){m=s.heap[--h];if(m>max_code){continue}if(tree[m*2+1]!==bits){s.opt_len+=(bits-tree[m*2+1])*tree[m*2];tree[m*2+1]=bits}n--}}};const gen_codes=(tree,max_code,bl_count)=>{const next_code=new Array(MAX_BITS$1+1);let code=0;let bits;let n;for(bits=1;bits<=MAX_BITS$1;bits++){code=code+bl_count[bits-1]<<1;next_code[bits]=code}for(n=0;n<=max_code;n++){let len=tree[n*2+1];if(len===0){continue}tree[n*2]=bi_reverse(next_code[len]++,len)}};const tr_static_init=()=>{let n;let bits;let length;let code;let dist;const bl_count=new Array(MAX_BITS$1+1);length=0;for(code=0;code<LENGTH_CODES$1-1;code++){base_length[code]=length;for(n=0;n<1<<extra_lbits[code];n++){_length_code[length++]=code}}_length_code[length-1]=code;dist=0;for(code=0;code<16;code++){base_dist[code]=dist;for(n=0;n<1<<extra_dbits[code];n++){_dist_code[dist++]=code}}dist>>=7;for(;code<D_CODES$1;code++){base_dist[code]=dist<<7;for(n=0;n<1<<extra_dbits[code]-7;n++){_dist_code[256+dist++]=code}}for(bits=0;bits<=MAX_BITS$1;bits++){bl_count[bits]=0}n=0;while(n<=143){static_ltree[n*2+1]=8;n++;bl_count[8]++}while(n<=255){static_ltree[n*2+1]=9;n++;bl_count[9]++}while(n<=279){static_ltree[n*2+1]=7;n++;bl_count[7]++}while(n<=287){static_ltree[n*2+1]=8;n++;bl_count[8]++}gen_codes(static_ltree,L_CODES$1+1,bl_count);for(n=0;n<D_CODES$1;n++){static_dtree[n*2+1]=5;static_dtree[n*2]=bi_reverse(n,5)}static_l_desc=new StaticTreeDesc(static_ltree,extra_lbits,LITERALS$1+1,L_CODES$1,MAX_BITS$1);static_d_desc=new StaticTreeDesc(static_dtree,extra_dbits,0,D_CODES$1,MAX_BITS$1);static_bl_desc=new StaticTreeDesc(new Array(0),extra_blbits,0,BL_CODES$1,MAX_BL_BITS)};const init_block=s=>{let n;for(n=0;n<L_CODES$1;n++){s.dyn_ltree[n*2]=0}for(n=0;n<D_CODES$1;n++){s.dyn_dtree[n*2]=0}for(n=0;n<BL_CODES$1;n++){s.bl_tree[n*2]=0}s.dyn_ltree[END_BLOCK*2]=1;s.opt_len=s.static_len=0;s.sym_next=s.matches=0};const bi_windup=s=>{if(s.bi_valid>8){put_short(s,s.bi_buf)}else if(s.bi_valid>0){s.pending_buf[s.pending++]=s.bi_buf}s.bi_buf=0;s.bi_valid=0};const smaller=(tree,n,m,depth)=>{const _n2=n*2;const _m2=m*2;return tree[_n2]<tree[_m2]||tree[_n2]===tree[_m2]&&depth[n]<=depth[m]};const pqdownheap=(s,tree,k)=>{const v=s.heap[k];let j=k<<1;while(j<=s.heap_len){if(j<s.heap_len&&smaller(tree,s.heap[j+1],s.heap[j],s.depth)){j++}if(smaller(tree,v,s.heap[j],s.depth)){break}s.heap[k]=s.heap[j];k=j;j<<=1}s.heap[k]=v};const compress_block=(s,ltree,dtree)=>{let dist;let lc;let sx=0;let code;let extra;if(s.sym_next!==0){do{dist=s.pending_buf[s.sym_buf+sx++]&255;dist+=(s.pending_buf[s.sym_buf+sx++]&255)<<8;lc=s.pending_buf[s.sym_buf+sx++];if(dist===0){send_code(s,lc,ltree)}else{code=_length_code[lc];send_code(s,code+LITERALS$1+1,ltree);extra=extra_lbits[code];if(extra!==0){lc-=base_length[code];send_bits(s,lc,extra)}dist--;code=d_code(dist);send_code(s,code,dtree);extra=extra_dbits[code];if(extra!==0){dist-=base_dist[code];send_bits(s,dist,extra)}}}while(sx<s.sym_next)}send_code(s,END_BLOCK,ltree)};const build_tree=(s,desc)=>{const tree=desc.dyn_tree;const stree=desc.stat_desc.static_tree;const has_stree=desc.stat_desc.has_stree;const elems=desc.stat_desc.elems;let n,m;let max_code=-1;let node;s.heap_len=0;s.heap_max=HEAP_SIZE$1;for(n=0;n<elems;n++){if(tree[n*2]!==0){s.heap[++s.heap_len]=max_code=n;s.depth[n]=0}else{tree[n*2+1]=0}}while(s.heap_len<2){node=s.heap[++s.heap_len]=max_code<2?++max_code:0;tree[node*2]=1;s.depth[node]=0;s.opt_len--;if(has_stree){s.static_len-=stree[node*2+1]}}desc.max_code=max_code;for(n=s.heap_len>>1;n>=1;n--){pqdownheap(s,tree,n)}node=elems;do{n=s.heap[1];s.heap[1]=s.heap[s.heap_len--];pqdownheap(s,tree,1);m=s.heap[1];s.heap[--s.heap_max]=n;s.heap[--s.heap_max]=m;tree[node*2]=tree[n*2]+tree[m*2];s.depth[node]=(s.depth[n]>=s.depth[m]?s.depth[n]:s.depth[m])+1;tree[n*2+1]=tree[m*2+1]=node;s.heap[1]=node++;pqdownheap(s,tree,1)}while(s.heap_len>=2);s.heap[--s.heap_max]=s.heap[1];gen_bitlen(s,desc);gen_codes(tree,max_code,s.bl_count)};const scan_tree=(s,tree,max_code)=>{let n;let prevlen=-1;let curlen;let nextlen=tree[0*2+1];let count=0;let max_count=7;let min_count=4;if(nextlen===0){max_count=138;min_count=3}tree[(max_code+1)*2+1]=65535;for(n=0;n<=max_code;n++){curlen=nextlen;nextlen=tree[(n+1)*2+1];if(++count<max_count&&curlen===nextlen){continue}else if(count<min_count){s.bl_tree[curlen*2]+=count}else if(curlen!==0){if(curlen!==prevlen){s.bl_tree[curlen*2]++}s.bl_tree[REP_3_6*2]++}else if(count<=10){s.bl_tree[REPZ_3_10*2]++}else{s.bl_tree[REPZ_11_138*2]++}count=0;prevlen=curlen;if(nextlen===0){max_count=138;min_count=3}else if(curlen===nextlen){max_count=6;min_count=3}else{max_count=7;min_count=4}}};const send_tree=(s,tree,max_code)=>{let n;let prevlen=-1;let curlen;let nextlen=tree[0*2+1];let count=0;let max_count=7;let min_count=4;if(nextlen===0){max_count=138;min_count=3}for(n=0;n<=max_code;n++){curlen=nextlen;nextlen=tree[(n+1)*2+1];if(++count<max_count&&curlen===nextlen){continue}else if(count<min_count){do{send_code(s,curlen,s.bl_tree)}while(--count!==0)}else if(curlen!==0){if(curlen!==prevlen){send_code(s,curlen,s.bl_tree);count--}send_code(s,REP_3_6,s.bl_tree);send_bits(s,count-3,2)}else if(count<=10){send_code(s,REPZ_3_10,s.bl_tree);send_bits(s,count-3,3)}else{send_code(s,REPZ_11_138,s.bl_tree);send_bits(s,count-11,7)}count=0;prevlen=curlen;if(nextlen===0){max_count=138;min_count=3}else if(curlen===nextlen){max_count=6;min_count=3}else{max_count=7;min_count=4}}};const build_bl_tree=s=>{let max_blindex;scan_tree(s,s.dyn_ltree,s.l_desc.max_code);scan_tree(s,s.dyn_dtree,s.d_desc.max_code);build_tree(s,s.bl_desc);for(max_blindex=BL_CODES$1-1;max_blindex>=3;max_blindex--){if(s.bl_tree[bl_order[max_blindex]*2+1]!==0){break}}s.opt_len+=3*(max_blindex+1)+5+5+4;return max_blindex};const send_all_trees=(s,lcodes,dcodes,blcodes)=>{let rank;send_bits(s,lcodes-257,5);send_bits(s,dcodes-1,5);send_bits(s,blcodes-4,4);for(rank=0;rank<blcodes;rank++){send_bits(s,s.bl_tree[bl_order[rank]*2+1],3)}send_tree(s,s.dyn_ltree,lcodes-1);send_tree(s,s.dyn_dtree,dcodes-1)};const detect_data_type=s=>{let block_mask=4093624447;let n;for(n=0;n<=31;n++,block_mask>>>=1){if(block_mask&1&&s.dyn_ltree[n*2]!==0){return Z_BINARY}}if(s.dyn_ltree[9*2]!==0||s.dyn_ltree[10*2]!==0||s.dyn_ltree[13*2]!==0){return Z_TEXT}for(n=32;n<LITERALS$1;n++){if(s.dyn_ltree[n*2]!==0){return Z_TEXT}}return Z_BINARY};let static_init_done=false;const _tr_init$1=s=>{if(!static_init_done){tr_static_init();static_init_done=true}s.l_desc=new TreeDesc(s.dyn_ltree,static_l_desc);s.d_desc=new TreeDesc(s.dyn_dtree,static_d_desc);s.bl_desc=new TreeDesc(s.bl_tree,static_bl_desc);s.bi_buf=0;s.bi_valid=0;init_block(s)};const _tr_stored_block$1=(s,buf,stored_len,last)=>{send_bits(s,(STORED_BLOCK<<1)+(last?1:0),3);bi_windup(s);put_short(s,stored_len);put_short(s,~stored_len);if(stored_len){s.pending_buf.set(s.window.subarray(buf,buf+stored_len),s.pending)}s.pending+=stored_len};const _tr_align$1=s=>{send_bits(s,STATIC_TREES<<1,3);send_code(s,END_BLOCK,static_ltree);bi_flush(s)};const _tr_flush_block$1=(s,buf,stored_len,last)=>{let opt_lenb,static_lenb;let max_blindex=0;if(s.level>0){if(s.strm.data_type===Z_UNKNOWN$1){s.strm.data_type=detect_data_type(s)}build_tree(s,s.l_desc);build_tree(s,s.d_desc);max_blindex=build_bl_tree(s);opt_lenb=s.opt_len+3+7>>>3;static_lenb=s.static_len+3+7>>>3;if(static_lenb<=opt_lenb){opt_lenb=static_lenb}}else{opt_lenb=static_lenb=stored_len+5}if(stored_len+4<=opt_lenb&&buf!==-1){_tr_stored_block$1(s,buf,stored_len,last)}else if(s.strategy===Z_FIXED$1||static_lenb===opt_lenb){send_bits(s,(STATIC_TREES<<1)+(last?1:0),3);compress_block(s,static_ltree,static_dtree)}else{send_bits(s,(DYN_TREES<<1)+(last?1:0),3);send_all_trees(s,s.l_desc.max_code+1,s.d_desc.max_code+1,max_blindex+1);compress_block(s,s.dyn_ltree,s.dyn_dtree)}init_block(s);if(last){bi_windup(s)}};const _tr_tally$1=(s,dist,lc)=>{s.pending_buf[s.sym_buf+s.sym_next++]=dist;s.pending_buf[s.sym_buf+s.sym_next++]=dist>>8;s.pending_buf[s.sym_buf+s.sym_next++]=lc;if(dist===0){s.dyn_ltree[lc*2]++}else{s.matches++;dist--;s.dyn_ltree[(_length_code[lc]+LITERALS$1+1)*2]++;s.dyn_dtree[d_code(dist)*2]++}return s.sym_next===s.sym_end};var _tr_init_1=_tr_init$1;var _tr_stored_block_1=_tr_stored_block$1;var _tr_flush_block_1=_tr_flush_block$1;var _tr_tally_1=_tr_tally$1;var _tr_align_1=_tr_align$1;var trees={_tr_init:_tr_init_1,_tr_stored_block:_tr_stored_block_1,_tr_flush_block:_tr_flush_block_1,_tr_tally:_tr_tally_1,_tr_align:_tr_align_1};const adler32=(adler,buf,len,pos)=>{let s1=adler&65535|0,s2=adler>>>16&65535|0,n=0;while(len!==0){n=len>2e3?2e3:len;len-=n;do{s1=s1+buf[pos++]|0;s2=s2+s1|0}while(--n);s1%=65521;s2%=65521}return s1|s2<<16|0};var adler32_1=adler32;const makeTable=()=>{let c,table=[];for(var n=0;n<256;n++){c=n;for(var k=0;k<8;k++){c=c&1?3988292384^c>>>1:c>>>1}table[n]=c}return table};const crcTable=new Uint32Array(makeTable());const crc32=(crc,buf,len,pos)=>{const t=crcTable;const end=pos+len;crc^=-1;for(let i=pos;i<end;i++){crc=crc>>>8^t[(crc^buf[i])&255]}return crc^-1};var crc32_1=crc32;var messages={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"};var constants$2={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init,_tr_stored_block,_tr_flush_block,_tr_tally,_tr_align}=trees;const{Z_NO_FLUSH:Z_NO_FLUSH$2,Z_PARTIAL_FLUSH,Z_FULL_FLUSH:Z_FULL_FLUSH$1,Z_FINISH:Z_FINISH$3,Z_BLOCK:Z_BLOCK$1,Z_OK:Z_OK$3,Z_STREAM_END:Z_STREAM_END$3,Z_STREAM_ERROR:Z_STREAM_ERROR$2,Z_DATA_ERROR:Z_DATA_ERROR$2,Z_BUF_ERROR:Z_BUF_ERROR$1,Z_DEFAULT_COMPRESSION:Z_DEFAULT_COMPRESSION$1,Z_FILTERED,Z_HUFFMAN_ONLY,Z_RLE,Z_FIXED,Z_DEFAULT_STRATEGY:Z_DEFAULT_STRATEGY$1,Z_UNKNOWN,Z_DEFLATED:Z_DEFLATED$2}=constants$2;const MAX_MEM_LEVEL=9;const MAX_WBITS$1=15;const DEF_MEM_LEVEL=8;const LENGTH_CODES=29;const LITERALS=256;const L_CODES=LITERALS+1+LENGTH_CODES;const D_CODES=30;const BL_CODES=19;const HEAP_SIZE=2*L_CODES+1;const MAX_BITS=15;const MIN_MATCH=3;const MAX_MATCH=258;const MIN_LOOKAHEAD=MAX_MATCH+MIN_MATCH+1;const PRESET_DICT=32;const INIT_STATE=42;const GZIP_STATE=57;const EXTRA_STATE=69;const NAME_STATE=73;const COMMENT_STATE=91;const HCRC_STATE=103;const BUSY_STATE=113;const FINISH_STATE=666;const BS_NEED_MORE=1;const BS_BLOCK_DONE=2;const BS_FINISH_STARTED=3;const BS_FINISH_DONE=4;const OS_CODE=3;const err=(strm,errorCode)=>{strm.msg=messages[errorCode];return errorCode};const rank=f=>{return f*2-(f>4?9:0)};const zero=buf=>{let len=buf.length;while(--len>=0){buf[len]=0}};const slide_hash=s=>{let n,m;let p;let wsize=s.w_size;n=s.hash_size;p=n;do{m=s.head[--p];s.head[p]=m>=wsize?m-wsize:0}while(--n);n=wsize;p=n;do{m=s.prev[--p];s.prev[p]=m>=wsize?m-wsize:0}while(--n)};let HASH_ZLIB=(s,prev,data)=>(prev<<s.hash_shift^data)&s.hash_mask;let HASH=HASH_ZLIB;const flush_pending=strm=>{const s=strm.state;let len=s.pending;if(len>strm.avail_out){len=strm.avail_out}if(len===0){return}strm.output.set(s.pending_buf.subarray(s.pending_out,s.pending_out+len),strm.next_out);strm.next_out+=len;s.pending_out+=len;strm.total_out+=len;strm.avail_out-=len;s.pending-=len;if(s.pending===0){s.pending_out=0}};const flush_block_only=(s,last)=>{_tr_flush_block(s,s.block_start>=0?s.block_start:-1,s.strstart-s.block_start,last);s.block_start=s.strstart;flush_pending(s.strm)};const put_byte=(s,b)=>{s.pending_buf[s.pending++]=b};const putShortMSB=(s,b)=>{s.pending_buf[s.pending++]=b>>>8&255;s.pending_buf[s.pending++]=b&255};const read_buf=(strm,buf,start,size)=>{let len=strm.avail_in;if(len>size){len=size}if(len===0){return 0}strm.avail_in-=len;buf.set(strm.input.subarray(strm.next_in,strm.next_in+len),start);if(strm.state.wrap===1){strm.adler=adler32_1(strm.adler,buf,len,start)}else if(strm.state.wrap===2){strm.adler=crc32_1(strm.adler,buf,len,start)}strm.next_in+=len;strm.total_in+=len;return len};const longest_match=(s,cur_match)=>{let chain_length=s.max_chain_length;let scan=s.strstart;let match;let len;let best_len=s.prev_length;let nice_match=s.nice_match;const limit=s.strstart>s.w_size-MIN_LOOKAHEAD?s.strstart-(s.w_size-MIN_LOOKAHEAD):0;const _win=s.window;const wmask=s.w_mask;const prev=s.prev;const strend=s.strstart+MAX_MATCH;let scan_end1=_win[scan+best_len-1];let scan_end=_win[scan+best_len];if(s.prev_length>=s.good_match){chain_length>>=2}if(nice_match>s.lookahead){nice_match=s.lookahead}do{match=cur_match;if(_win[match+best_len]!==scan_end||_win[match+best_len-1]!==scan_end1||_win[match]!==_win[scan]||_win[++match]!==_win[scan+1]){continue}scan+=2;match++;do{}while(_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&scan<strend);len=MAX_MATCH-(strend-scan);scan=strend-MAX_MATCH;if(len>best_len){s.match_start=cur_match;best_len=len;if(len>=nice_match){break}scan_end1=_win[scan+best_len-1];scan_end=_win[scan+best_len]}}while((cur_match=prev[cur_match&wmask])>limit&&--chain_length!==0);if(best_len<=s.lookahead){return best_len}return s.lookahead};const fill_window=s=>{const _w_size=s.w_size;let n,more,str;do{more=s.window_size-s.lookahead-s.strstart;if(s.strstart>=_w_size+(_w_size-MIN_LOOKAHEAD)){s.window.set(s.window.subarray(_w_size,_w_size+_w_size-more),0);s.match_start-=_w_size;s.strstart-=_w_size;s.block_start-=_w_size;if(s.insert>s.strstart){s.insert=s.strstart}slide_hash(s);more+=_w_size}if(s.strm.avail_in===0){break}n=read_buf(s.strm,s.window,s.strstart+s.lookahead,more);s.lookahead+=n;if(s.lookahead+s.insert>=MIN_MATCH){str=s.strstart-s.insert;s.ins_h=s.window[str];s.ins_h=HASH(s,s.ins_h,s.window[str+1]);while(s.insert){s.ins_h=HASH(s,s.ins_h,s.window[str+MIN_MATCH-1]);s.prev[str&s.w_mask]=s.head[s.ins_h];s.head[s.ins_h]=str;str++;s.insert--;if(s.lookahead+s.insert<MIN_MATCH){break}}}}while(s.lookahead<MIN_LOOKAHEAD&&s.strm.avail_in!==0)};const deflate_stored=(s,flush)=>{let min_block=s.pending_buf_size-5>s.w_size?s.w_size:s.pending_buf_size-5;let len,left,have,last=0;let used=s.strm.avail_in;do{len=65535;have=s.bi_valid+42>>3;if(s.strm.avail_out<have){break}have=s.strm.avail_out-have;left=s.strstart-s.block_start;if(len>left+s.strm.avail_in){len=left+s.strm.avail_in}if(len>have){len=have}if(len<min_block&&(len===0&&flush!==Z_FINISH$3||flush===Z_NO_FLUSH$2||len!==left+s.strm.avail_in)){break}last=flush===Z_FINISH$3&&len===left+s.strm.avail_in?1:0;_tr_stored_block(s,0,0,last);s.pending_buf[s.pending-4]=len;s.pending_buf[s.pending-3]=len>>8;s.pending_buf[s.pending-2]=~len;s.pending_buf[s.pending-1]=~len>>8;flush_pending(s.strm);if(left){if(left>len){left=len}s.strm.output.set(s.window.subarray(s.block_start,s.block_start+left),s.strm.next_out);s.strm.next_out+=left;s.strm.avail_out-=left;s.strm.total_out+=left;s.block_start+=left;len-=left}if(len){read_buf(s.strm,s.strm.output,s.strm.next_out,len);s.strm.next_out+=len;s.strm.avail_out-=len;s.strm.total_out+=len}}while(last===0);used-=s.strm.avail_in;if(used){if(used>=s.w_size){s.matches=2;s.window.set(s.strm.input.subarray(s.strm.next_in-s.w_size,s.strm.next_in),0);s.strstart=s.w_size;s.insert=s.strstart}else{if(s.window_size-s.strstart<=used){s.strstart-=s.w_size;s.window.set(s.window.subarray(s.w_size,s.w_size+s.strstart),0);if(s.matches<2){s.matches++}if(s.insert>s.strstart){s.insert=s.strstart}}s.window.set(s.strm.input.subarray(s.strm.next_in-used,s.strm.next_in),s.strstart);s.strstart+=used;s.insert+=used>s.w_size-s.insert?s.w_size-s.insert:used}s.block_start=s.strstart}if(s.high_water<s.strstart){s.high_water=s.strstart}if(last){return BS_FINISH_DONE}if(flush!==Z_NO_FLUSH$2&&flush!==Z_FINISH$3&&s.strm.avail_in===0&&s.strstart===s.block_start){return BS_BLOCK_DONE}have=s.window_size-s.strstart;if(s.strm.avail_in>have&&s.block_start>=s.w_size){s.block_start-=s.w_size;s.strstart-=s.w_size;s.window.set(s.window.subarray(s.w_size,s.w_size+s.strstart),0);if(s.matches<2){s.matches++}have+=s.w_size;if(s.insert>s.strstart){s.insert=s.strstart}}if(have>s.strm.avail_in){have=s.strm.avail_in}if(have){read_buf(s.strm,s.window,s.strstart,have);s.strstart+=have;s.insert+=have>s.w_size-s.insert?s.w_size-s.insert:have}if(s.high_water<s.strstart){s.high_water=s.strstart}have=s.bi_valid+42>>3;have=s.pending_buf_size-have>65535?65535:s.pending_buf_size-have;min_block=have>s.w_size?s.w_size:have;left=s.strstart-s.block_start;if(left>=min_block||(left||flush===Z_FINISH$3)&&flush!==Z_NO_FLUSH$2&&s.strm.avail_in===0&&left<=have){len=left>have?have:left;last=flush===Z_FINISH$3&&s.strm.avail_in===0&&len===left?1:0;_tr_stored_block(s,s.block_start,len,last);s.block_start+=len;flush_pending(s.strm)}return last?BS_FINISH_STARTED:BS_NEED_MORE};const deflate_fast=(s,flush)=>{let hash_head;let bflush;for(;;){if(s.lookahead<MIN_LOOKAHEAD){fill_window(s);if(s.lookahead<MIN_LOOKAHEAD&&flush===Z_NO_FLUSH$2){return BS_NEED_MORE}if(s.lookahead===0){break}}hash_head=0;if(s.lookahead>=MIN_MATCH){s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+MIN_MATCH-1]);hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h];s.head[s.ins_h]=s.strstart}if(hash_head!==0&&s.strstart-hash_head<=s.w_size-MIN_LOOKAHEAD){s.match_length=longest_match(s,hash_head)}if(s.match_length>=MIN_MATCH){bflush=_tr_tally(s,s.strstart-s.match_start,s.match_length-MIN_MATCH);s.lookahead-=s.match_length;if(s.match_length<=s.max_lazy_match&&s.lookahead>=MIN_MATCH){s.match_length--;do{s.strstart++;s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+MIN_MATCH-1]);hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h];s.head[s.ins_h]=s.strstart}while(--s.match_length!==0);s.strstart++}else{s.strstart+=s.match_length;s.match_length=0;s.ins_h=s.window[s.strstart];s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+1])}}else{bflush=_tr_tally(s,0,s.window[s.strstart]);s.lookahead--;s.strstart++}if(bflush){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE}}}s.insert=s.strstart<MIN_MATCH-1?s.strstart:MIN_MATCH-1;if(flush===Z_FINISH$3){flush_block_only(s,true);if(s.strm.avail_out===0){return BS_FINISH_STARTED}return BS_FINISH_DONE}if(s.sym_next){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE}}return BS_BLOCK_DONE};const deflate_slow=(s,flush)=>{let hash_head;let bflush;let max_insert;for(;;){if(s.lookahead<MIN_LOOKAHEAD){fill_window(s);if(s.lookahead<MIN_LOOKAHEAD&&flush===Z_NO_FLUSH$2){return BS_NEED_MORE}if(s.lookahead===0){break}}hash_head=0;if(s.lookahead>=MIN_MATCH){s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+MIN_MATCH-1]);hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h];s.head[s.ins_h]=s.strstart}s.prev_length=s.match_length;s.prev_match=s.match_start;s.match_length=MIN_MATCH-1;if(hash_head!==0&&s.prev_length<s.max_lazy_match&&s.strstart-hash_head<=s.w_size-MIN_LOOKAHEAD){s.match_length=longest_match(s,hash_head);if(s.match_length<=5&&(s.strategy===Z_FILTERED||s.match_length===MIN_MATCH&&s.strstart-s.match_start>4096)){s.match_length=MIN_MATCH-1}}if(s.prev_length>=MIN_MATCH&&s.match_length<=s.prev_length){max_insert=s.strstart+s.lookahead-MIN_MATCH;bflush=_tr_tally(s,s.strstart-1-s.prev_match,s.prev_length-MIN_MATCH);s.lookahead-=s.prev_length-1;s.prev_length-=2;do{if(++s.strstart<=max_insert){s.ins_h=HASH(s,s.ins_h,s.window[s.strstart+MIN_MATCH-1]);hash_head=s.prev[s.strstart&s.w_mask]=s.head[s.ins_h];s.head[s.ins_h]=s.strstart}}while(--s.prev_length!==0);s.match_available=0;s.match_length=MIN_MATCH-1;s.strstart++;if(bflush){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE}}}else if(s.match_available){bflush=_tr_tally(s,0,s.window[s.strstart-1]);if(bflush){flush_block_only(s,false)}s.strstart++;s.lookahead--;if(s.strm.avail_out===0){return BS_NEED_MORE}}else{s.match_available=1;s.strstart++;s.lookahead--}}if(s.match_available){bflush=_tr_tally(s,0,s.window[s.strstart-1]);s.match_available=0}s.insert=s.strstart<MIN_MATCH-1?s.strstart:MIN_MATCH-1;if(flush===Z_FINISH$3){flush_block_only(s,true);if(s.strm.avail_out===0){return BS_FINISH_STARTED}return BS_FINISH_DONE}if(s.sym_next){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE}}return BS_BLOCK_DONE};const deflate_rle=(s,flush)=>{let bflush;let prev;let scan,strend;const _win=s.window;for(;;){if(s.lookahead<=MAX_MATCH){fill_window(s);if(s.lookahead<=MAX_MATCH&&flush===Z_NO_FLUSH$2){return BS_NEED_MORE}if(s.lookahead===0){break}}s.match_length=0;if(s.lookahead>=MIN_MATCH&&s.strstart>0){scan=s.strstart-1;prev=_win[scan];if(prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]){strend=s.strstart+MAX_MATCH;do{}while(prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&scan<strend);s.match_length=MAX_MATCH-(strend-scan);if(s.match_length>s.lookahead){s.match_length=s.lookahead}}}if(s.match_length>=MIN_MATCH){bflush=_tr_tally(s,1,s.match_length-MIN_MATCH);s.lookahead-=s.match_length;s.strstart+=s.match_length;s.match_length=0}else{bflush=_tr_tally(s,0,s.window[s.strstart]);s.lookahead--;s.strstart++}if(bflush){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE}}}s.insert=0;if(flush===Z_FINISH$3){flush_block_only(s,true);if(s.strm.avail_out===0){return BS_FINISH_STARTED}return BS_FINISH_DONE}if(s.sym_next){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE}}return BS_BLOCK_DONE};const deflate_huff=(s,flush)=>{let bflush;for(;;){if(s.lookahead===0){fill_window(s);if(s.lookahead===0){if(flush===Z_NO_FLUSH$2){return BS_NEED_MORE}break}}s.match_length=0;bflush=_tr_tally(s,0,s.window[s.strstart]);s.lookahead--;s.strstart++;if(bflush){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE}}}s.insert=0;if(flush===Z_FINISH$3){flush_block_only(s,true);if(s.strm.avail_out===0){return BS_FINISH_STARTED}return BS_FINISH_DONE}if(s.sym_next){flush_block_only(s,false);if(s.strm.avail_out===0){return BS_NEED_MORE}}return BS_BLOCK_DONE};function Config(good_length,max_lazy,nice_length,max_chain,func){this.good_length=good_length;this.max_lazy=max_lazy;this.nice_length=nice_length;this.max_chain=max_chain;this.func=func}const configuration_table=[new Config(0,0,0,0,deflate_stored),new Config(4,4,8,4,deflate_fast),new Config(4,5,16,8,deflate_fast),new Config(4,6,32,32,deflate_fast),new Config(4,4,16,16,deflate_slow),new Config(8,16,32,32,deflate_slow),new Config(8,16,128,128,deflate_slow),new Config(8,32,128,256,deflate_slow),new Config(32,128,258,1024,deflate_slow),new Config(32,258,258,4096,deflate_slow)];const lm_init=s=>{s.window_size=2*s.w_size;zero(s.head);s.max_lazy_match=configuration_table[s.level].max_lazy;s.good_match=configuration_table[s.level].good_length;s.nice_match=configuration_table[s.level].nice_length;s.max_chain_length=configuration_table[s.level].max_chain;s.strstart=0;s.block_start=0;s.lookahead=0;s.insert=0;s.match_length=s.prev_length=MIN_MATCH-1;s.match_available=0;s.ins_h=0};function DeflateState(){this.strm=null;this.status=0;this.pending_buf=null;this.pending_buf_size=0;this.pending_out=0;this.pending=0;this.wrap=0;this.gzhead=null;this.gzindex=0;this.method=Z_DEFLATED$2;this.last_flush=-1;this.w_size=0;this.w_bits=0;this.w_mask=0;this.window=null;this.window_size=0;this.prev=null;this.head=null;this.ins_h=0;this.hash_size=0;this.hash_bits=0;this.hash_mask=0;this.hash_shift=0;this.block_start=0;this.match_length=0;this.prev_match=0;this.match_available=0;this.strstart=0;this.match_start=0;this.lookahead=0;this.prev_length=0;this.max_chain_length=0;this.max_lazy_match=0;this.level=0;this.strategy=0;this.good_match=0;this.nice_match=0;this.dyn_ltree=new Uint16Array(HEAP_SIZE*2);this.dyn_dtree=new Uint16Array((2*D_CODES+1)*2);this.bl_tree=new Uint16Array((2*BL_CODES+1)*2);zero(this.dyn_ltree);zero(this.dyn_dtree);zero(this.bl_tree);this.l_desc=null;this.d_desc=null;this.bl_desc=null;this.bl_count=new Uint16Array(MAX_BITS+1);this.heap=new Uint16Array(2*L_CODES+1);zero(this.heap);this.heap_len=0;this.heap_max=0;this.depth=new Uint16Array(2*L_CODES+1);zero(this.depth);this.sym_buf=0;this.lit_bufsize=0;this.sym_next=0;this.sym_end=0;this.opt_len=0;this.static_len=0;this.matches=0;this.insert=0;this.bi_buf=0;this.bi_valid=0}const deflateStateCheck=strm=>{if(!strm){return 1}const s=strm.state;if(!s||s.strm!==strm||s.status!==INIT_STATE&&s.status!==GZIP_STATE&&s.status!==EXTRA_STATE&&s.status!==NAME_STATE&&s.status!==COMMENT_STATE&&s.status!==HCRC_STATE&&s.status!==BUSY_STATE&&s.status!==FINISH_STATE){return 1}return 0};const deflateResetKeep=strm=>{if(deflateStateCheck(strm)){return err(strm,Z_STREAM_ERROR$2)}strm.total_in=strm.total_out=0;strm.data_type=Z_UNKNOWN;const s=strm.state;s.pending=0;s.pending_out=0;if(s.wrap<0){s.wrap=-s.wrap}s.status=s.wrap===2?GZIP_STATE:s.wrap?INIT_STATE:BUSY_STATE;strm.adler=s.wrap===2?0:1;s.last_flush=-2;_tr_init(s);return Z_OK$3};const deflateReset=strm=>{const ret=deflateResetKeep(strm);if(ret===Z_OK$3){lm_init(strm.state)}return ret};const deflateSetHeader=(strm,head)=>{if(deflateStateCheck(strm)||strm.state.wrap!==2){return Z_STREAM_ERROR$2}strm.state.gzhead=head;return Z_OK$3};const deflateInit2=(strm,level,method,windowBits,memLevel,strategy)=>{if(!strm){return Z_STREAM_ERROR$2}let wrap=1;if(level===Z_DEFAULT_COMPRESSION$1){level=6}if(windowBits<0){wrap=0;windowBits=-windowBits}else if(windowBits>15){wrap=2;windowBits-=16}if(memLevel<1||memLevel>MAX_MEM_LEVEL||method!==Z_DEFLATED$2||windowBits<8||windowBits>15||level<0||level>9||strategy<0||strategy>Z_FIXED||windowBits===8&&wrap!==1){return err(strm,Z_STREAM_ERROR$2)}if(windowBits===8){windowBits=9}const s=new DeflateState;strm.state=s;s.strm=strm;s.status=INIT_STATE;s.wrap=wrap;s.gzhead=null;s.w_bits=windowBits;s.w_size=1<<s.w_bits;s.w_mask=s.w_size-1;s.hash_bits=memLevel+7;s.hash_size=1<<s.hash_bits;s.hash_mask=s.hash_size-1;s.hash_shift=~~((s.hash_bits+MIN_MATCH-1)/MIN_MATCH);s.window=new Uint8Array(s.w_size*2);s.head=new Uint16Array(s.hash_size);s.prev=new Uint16Array(s.w_size);s.lit_bufsize=1<<memLevel+6;s.pending_buf_size=s.lit_bufsize*4;s.pending_buf=new Uint8Array(s.pending_buf_size);s.sym_buf=s.lit_bufsize;s.sym_end=(s.lit_bufsize-1)*3;s.level=level;s.strategy=strategy;s.method=method;return deflateReset(strm)};const deflateInit=(strm,level)=>{return deflateInit2(strm,level,Z_DEFLATED$2,MAX_WBITS$1,DEF_MEM_LEVEL,Z_DEFAULT_STRATEGY$1)};const deflate$2=(strm,flush)=>{if(deflateStateCheck(strm)||flush>Z_BLOCK$1||flush<0){return strm?err(strm,Z_STREAM_ERROR$2):Z_STREAM_ERROR$2}const s=strm.state;if(!strm.output||strm.avail_in!==0&&!strm.input||s.status===FINISH_STATE&&flush!==Z_FINISH$3){return err(strm,strm.avail_out===0?Z_BUF_ERROR$1:Z_STREAM_ERROR$2)}const old_flush=s.last_flush;s.last_flush=flush;if(s.pending!==0){flush_pending(strm);if(strm.avail_out===0){s.last_flush=-1;return Z_OK$3}}else if(strm.avail_in===0&&rank(flush)<=rank(old_flush)&&flush!==Z_FINISH$3){return err(strm,Z_BUF_ERROR$1)}if(s.status===FINISH_STATE&&strm.avail_in!==0){return err(strm,Z_BUF_ERROR$1)}if(s.status===INIT_STATE&&s.wrap===0){s.status=BUSY_STATE}if(s.status===INIT_STATE){let header=Z_DEFLATED$2+(s.w_bits-8<<4)<<8;let level_flags=-1;if(s.strategy>=Z_HUFFMAN_ONLY||s.level<2){level_flags=0}else if(s.level<6){level_flags=1}else if(s.level===6){level_flags=2}else{level_flags=3}header|=level_flags<<6;if(s.strstart!==0){header|=PRESET_DICT}header+=31-header%31;putShortMSB(s,header);if(s.strstart!==0){putShortMSB(s,strm.adler>>>16);putShortMSB(s,strm.adler&65535)}strm.adler=1;s.status=BUSY_STATE;flush_pending(strm);if(s.pending!==0){s.last_flush=-1;return Z_OK$3}}if(s.status===GZIP_STATE){strm.adler=0;put_byte(s,31);put_byte(s,139);put_byte(s,8);if(!s.gzhead){put_byte(s,0);put_byte(s,0);put_byte(s,0);put_byte(s,0);put_byte(s,0);put_byte(s,s.level===9?2:s.strategy>=Z_HUFFMAN_ONLY||s.level<2?4:0);put_byte(s,OS_CODE);s.status=BUSY_STATE;flush_pending(strm);if(s.pending!==0){s.last_flush=-1;return Z_OK$3}}else{put_byte(s,(s.gzhead.text?1:0)+(s.gzhead.hcrc?2:0)+(!s.gzhead.extra?0:4)+(!s.gzhead.name?0:8)+(!s.gzhead.comment?0:16));put_byte(s,s.gzhead.time&255);put_byte(s,s.gzhead.time>>8&255);put_byte(s,s.gzhead.time>>16&255);put_byte(s,s.gzhead.time>>24&255);put_byte(s,s.level===9?2:s.strategy>=Z_HUFFMAN_ONLY||s.level<2?4:0);put_byte(s,s.gzhead.os&255);if(s.gzhead.extra&&s.gzhead.extra.length){put_byte(s,s.gzhead.extra.length&255);put_byte(s,s.gzhead.extra.length>>8&255)}if(s.gzhead.hcrc){strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending,0)}s.gzindex=0;s.status=EXTRA_STATE}}if(s.status===EXTRA_STATE){if(s.gzhead.extra){let beg=s.pending;let left=(s.gzhead.extra.length&65535)-s.gzindex;while(s.pending+left>s.pending_buf_size){let copy=s.pending_buf_size-s.pending;s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex,s.gzindex+copy),s.pending);s.pending=s.pending_buf_size;if(s.gzhead.hcrc&&s.pending>beg){strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg)}s.gzindex+=copy;flush_pending(strm);if(s.pending!==0){s.last_flush=-1;return Z_OK$3}beg=0;left-=copy}let gzhead_extra=new Uint8Array(s.gzhead.extra);s.pending_buf.set(gzhead_extra.subarray(s.gzindex,s.gzindex+left),s.pending);s.pending+=left;if(s.gzhead.hcrc&&s.pending>beg){strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg)}s.gzindex=0}s.status=NAME_STATE}if(s.status===NAME_STATE){if(s.gzhead.name){let beg=s.pending;let val;do{if(s.pending===s.pending_buf_size){if(s.gzhead.hcrc&&s.pending>beg){strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg)}flush_pending(strm);if(s.pending!==0){s.last_flush=-1;return Z_OK$3}beg=0}if(s.gzindex<s.gzhead.name.length){val=s.gzhead.name.charCodeAt(s.gzindex++)&255}else{val=0}put_byte(s,val)}while(val!==0);if(s.gzhead.hcrc&&s.pending>beg){strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg)}s.gzindex=0}s.status=COMMENT_STATE}if(s.status===COMMENT_STATE){if(s.gzhead.comment){let beg=s.pending;let val;do{if(s.pending===s.pending_buf_size){if(s.gzhead.hcrc&&s.pending>beg){strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg)}flush_pending(strm);if(s.pending!==0){s.last_flush=-1;return Z_OK$3}beg=0}if(s.gzindex<s.gzhead.comment.length){val=s.gzhead.comment.charCodeAt(s.gzindex++)&255}else{val=0}put_byte(s,val)}while(val!==0);if(s.gzhead.hcrc&&s.pending>beg){strm.adler=crc32_1(strm.adler,s.pending_buf,s.pending-beg,beg)}}s.status=HCRC_STATE}if(s.status===HCRC_STATE){if(s.gzhead.hcrc){if(s.pending+2>s.pending_buf_size){flush_pending(strm);if(s.pending!==0){s.last_flush=-1;return Z_OK$3}}put_byte(s,strm.adler&255);put_byte(s,strm.adler>>8&255);strm.adler=0}s.status=BUSY_STATE;flush_pending(strm);if(s.pending!==0){s.last_flush=-1;return Z_OK$3}}if(strm.avail_in!==0||s.lookahead!==0||flush!==Z_NO_FLUSH$2&&s.status!==FINISH_STATE){let bstate=s.level===0?deflate_stored(s,flush):s.strategy===Z_HUFFMAN_ONLY?deflate_huff(s,flush):s.strategy===Z_RLE?deflate_rle(s,flush):configuration_table[s.level].func(s,flush);if(bstate===BS_FINISH_STARTED||bstate===BS_FINISH_DONE){s.status=FINISH_STATE}if(bstate===BS_NEED_MORE||bstate===BS_FINISH_STARTED){if(strm.avail_out===0){s.last_flush=-1}return Z_OK$3}if(bstate===BS_BLOCK_DONE){if(flush===Z_PARTIAL_FLUSH){_tr_align(s)}else if(flush!==Z_BLOCK$1){_tr_stored_block(s,0,0,false);if(flush===Z_FULL_FLUSH$1){zero(s.head);if(s.lookahead===0){s.strstart=0;s.block_start=0;s.insert=0}}}flush_pending(strm);if(strm.avail_out===0){s.last_flush=-1;return Z_OK$3}}}if(flush!==Z_FINISH$3){return Z_OK$3}if(s.wrap<=0){return Z_STREAM_END$3}if(s.wrap===2){put_byte(s,strm.adler&255);put_byte(s,strm.adler>>8&255);put_byte(s,strm.adler>>16&255);put_byte(s,strm.adler>>24&255);put_byte(s,strm.total_in&255);put_byte(s,strm.total_in>>8&255);put_byte(s,strm.total_in>>16&255);put_byte(s,strm.total_in>>24&255)}else{putShortMSB(s,strm.adler>>>16);putShortMSB(s,strm.adler&65535)}flush_pending(strm);if(s.wrap>0){s.wrap=-s.wrap}return s.pending!==0?Z_OK$3:Z_STREAM_END$3};const deflateEnd=strm=>{if(deflateStateCheck(strm)){return Z_STREAM_ERROR$2}const status=strm.state.status;strm.state=null;return status===BUSY_STATE?err(strm,Z_DATA_ERROR$2):Z_OK$3};const deflateSetDictionary=(strm,dictionary)=>{let dictLength=dictionary.length;if(deflateStateCheck(strm)){return Z_STREAM_ERROR$2}const s=strm.state;const wrap=s.wrap;if(wrap===2||wrap===1&&s.status!==INIT_STATE||s.lookahead){return Z_STREAM_ERROR$2}if(wrap===1){strm.adler=adler32_1(strm.adler,dictionary,dictLength,0)}s.wrap=0;if(dictLength>=s.w_size){if(wrap===0){zero(s.head);s.strstart=0;s.block_start=0;s.insert=0}let tmpDict=new Uint8Array(s.w_size);tmpDict.set(dictionary.subarray(dictLength-s.w_size,dictLength),0);dictionary=tmpDict;dictLength=s.w_size}const avail=strm.avail_in;const next=strm.next_in;const input=strm.input;strm.avail_in=dictLength;strm.next_in=0;strm.input=dictionary;fill_window(s);while(s.lookahead>=MIN_MATCH){let str=s.strstart;let n=s.lookahead-(MIN_MATCH-1);do{s.ins_h=HASH(s,s.ins_h,s.window[str+MIN_MATCH-1]);s.prev[str&s.w_mask]=s.head[s.ins_h];s.head[s.ins_h]=str;str++}while(--n);s.strstart=str;s.lookahead=MIN_MATCH-1;fill_window(s)}s.strstart+=s.lookahead;s.block_start=s.strstart;s.insert=s.lookahead;s.lookahead=0;s.match_length=s.prev_length=MIN_MATCH-1;s.match_available=0;strm.next_in=next;strm.input=input;strm.avail_in=avail;s.wrap=wrap;return Z_OK$3};var deflateInit_1=deflateInit;var deflateInit2_1=deflateInit2;var deflateReset_1=deflateReset;var deflateResetKeep_1=deflateResetKeep;var deflateSetHeader_1=deflateSetHeader;var deflate_2$1=deflate$2;var deflateEnd_1=deflateEnd;var deflateSetDictionary_1=deflateSetDictionary;var deflateInfo="pako deflate (from Nodeca project)";var deflate_1$2={deflateInit:deflateInit_1,deflateInit2:deflateInit2_1,deflateReset:deflateReset_1,deflateResetKeep:deflateResetKeep_1,deflateSetHeader:deflateSetHeader_1,deflate:deflate_2$1,deflateEnd:deflateEnd_1,deflateSetDictionary:deflateSetDictionary_1,deflateInfo:deflateInfo};const _has=(obj,key)=>{return Object.prototype.hasOwnProperty.call(obj,key)};var assign=function(obj){const sources=Array.prototype.slice.call(arguments,1);while(sources.length){const source=sources.shift();if(!source){continue}if(typeof source!=="object"){throw new TypeError(source+"must be non-object")}for(const p in source){if(_has(source,p)){obj[p]=source[p]}}}return obj};var flattenChunks=chunks=>{let len=0;for(let i=0,l=chunks.length;i<l;i++){len+=chunks[i].length}const result=new Uint8Array(len);for(let i=0,pos=0,l=chunks.length;i<l;i++){let chunk=chunks[i];result.set(chunk,pos);pos+=chunk.length}return result};var common={assign:assign,flattenChunks:flattenChunks};let STR_APPLY_UIA_OK=true;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(__){STR_APPLY_UIA_OK=false}const _utf8len=new Uint8Array(256);for(let q=0;q<256;q++){_utf8len[q]=q>=252?6:q>=248?5:q>=240?4:q>=224?3:q>=192?2:1}_utf8len[254]=_utf8len[254]=1;var string2buf=str=>{if(typeof TextEncoder==="function"&&TextEncoder.prototype.encode){return(new TextEncoder).encode(str)}let buf,c,c2,m_pos,i,str_len=str.length,buf_len=0;for(m_pos=0;m_pos<str_len;m_pos++){c=str.charCodeAt(m_pos);if((c&64512)===55296&&m_pos+1<str_len){c2=str.charCodeAt(m_pos+1);if((c2&64512)===56320){c=65536+(c-55296<<10)+(c2-56320);m_pos++}}buf_len+=c<128?1:c<2048?2:c<65536?3:4}buf=new Uint8Array(buf_len);for(i=0,m_pos=0;i<buf_len;m_pos++){c=str.charCodeAt(m_pos);if((c&64512)===55296&&m_pos+1<str_len){c2=str.charCodeAt(m_pos+1);if((c2&64512)===56320){c=65536+(c-55296<<10)+(c2-56320);m_pos++}}if(c<128){buf[i++]=c}else if(c<2048){buf[i++]=192|c>>>6;buf[i++]=128|c&63}else if(c<65536){buf[i++]=224|c>>>12;buf[i++]=128|c>>>6&63;buf[i++]=128|c&63}else{buf[i++]=240|c>>>18;buf[i++]=128|c>>>12&63;buf[i++]=128|c>>>6&63;buf[i++]=128|c&63}}return buf};const buf2binstring=(buf,len)=>{if(len<65534){if(buf.subarray&&STR_APPLY_UIA_OK){return String.fromCharCode.apply(null,buf.length===len?buf:buf.subarray(0,len))}}let result="";for(let i=0;i<len;i++){result+=String.fromCharCode(buf[i])}return result};var buf2string=(buf,max)=>{const len=max||buf.length;if(typeof TextDecoder==="function"&&TextDecoder.prototype.decode){return(new TextDecoder).decode(buf.subarray(0,max))}let i,out;const utf16buf=new Array(len*2);for(out=0,i=0;i<len;){let c=buf[i++];if(c<128){utf16buf[out++]=c;continue}let c_len=_utf8len[c];if(c_len>4){utf16buf[out++]=65533;i+=c_len-1;continue}c&=c_len===2?31:c_len===3?15:7;while(c_len>1&&i<len){c=c<<6|buf[i++]&63;c_len--}if(c_len>1){utf16buf[out++]=65533;continue}if(c<65536){utf16buf[out++]=c}else{c-=65536;utf16buf[out++]=55296|c>>10&1023;utf16buf[out++]=56320|c&1023}}return buf2binstring(utf16buf,out)};var utf8border=(buf,max)=>{max=max||buf.length;if(max>buf.length){max=buf.length}let pos=max-1;while(pos>=0&&(buf[pos]&192)===128){pos--}if(pos<0){return max}if(pos===0){return max}return pos+_utf8len[buf[pos]]>max?pos:max};var strings={string2buf:string2buf,buf2string:buf2string,utf8border:utf8border};function ZStream(){this.input=null;this.next_in=0;this.avail_in=0;this.total_in=0;this.output=null;this.next_out=0;this.avail_out=0;this.total_out=0;this.msg="";this.state=null;this.data_type=2;this.adler=0}var zstream=ZStream;const toString$1=Object.prototype.toString;const{Z_NO_FLUSH:Z_NO_FLUSH$1,Z_SYNC_FLUSH,Z_FULL_FLUSH,Z_FINISH:Z_FINISH$2,Z_OK:Z_OK$2,Z_STREAM_END:Z_STREAM_END$2,Z_DEFAULT_COMPRESSION,Z_DEFAULT_STRATEGY,Z_DEFLATED:Z_DEFLATED$1}=constants$2;function Deflate$1(options){this.options=common.assign({level:Z_DEFAULT_COMPRESSION,method:Z_DEFLATED$1,chunkSize:16384,windowBits:15,memLevel:8,strategy:Z_DEFAULT_STRATEGY},options||{});let opt=this.options;if(opt.raw&&opt.windowBits>0){opt.windowBits=-opt.windowBits}else if(opt.gzip&&opt.windowBits>0&&opt.windowBits<16){opt.windowBits+=16}this.err=0;this.msg="";this.ended=false;this.chunks=[];this.strm=new zstream;this.strm.avail_out=0;let status=deflate_1$2.deflateInit2(this.strm,opt.level,opt.method,opt.windowBits,opt.memLevel,opt.strategy);if(status!==Z_OK$2){throw new Error(messages[status])}if(opt.header){deflate_1$2.deflateSetHeader(this.strm,opt.header)}if(opt.dictionary){let dict;if(typeof opt.dictionary==="string"){dict=strings.string2buf(opt.dictionary)}else if(toString$1.call(opt.dictionary)==="[object ArrayBuffer]"){dict=new Uint8Array(opt.dictionary)}else{dict=opt.dictionary}status=deflate_1$2.deflateSetDictionary(this.strm,dict);if(status!==Z_OK$2){throw new Error(messages[status])}this._dict_set=true}}Deflate$1.prototype.push=function(data,flush_mode){const strm=this.strm;const chunkSize=this.options.chunkSize;let status,_flush_mode;if(this.ended){return false}if(flush_mode===~~flush_mode)_flush_mode=flush_mode;else _flush_mode=flush_mode===true?Z_FINISH$2:Z_NO_FLUSH$1;if(typeof data==="string"){strm.input=strings.string2buf(data)}else if(toString$1.call(data)==="[object ArrayBuffer]"){strm.input=new Uint8Array(data)}else{strm.input=data}strm.next_in=0;strm.avail_in=strm.input.length;for(;;){if(strm.avail_out===0){strm.output=new Uint8Array(chunkSize);strm.next_out=0;strm.avail_out=chunkSize}if((_flush_mode===Z_SYNC_FLUSH||_flush_mode===Z_FULL_FLUSH)&&strm.avail_out<=6){this.onData(strm.output.subarray(0,strm.next_out));strm.avail_out=0;continue}status=deflate_1$2.deflate(strm,_flush_mode);if(status===Z_STREAM_END$2){if(strm.next_out>0){this.onData(strm.output.subarray(0,strm.next_out))}status=deflate_1$2.deflateEnd(this.strm);this.onEnd(status);this.ended=true;return status===Z_OK$2}if(strm.avail_out===0){this.onData(strm.output);continue}if(_flush_mode>0&&strm.next_out>0){this.onData(strm.output.subarray(0,strm.next_out));strm.avail_out=0;continue}if(strm.avail_in===0)break}return true};Deflate$1.prototype.onData=function(chunk){this.chunks.push(chunk)};Deflate$1.prototype.onEnd=function(status){if(status===Z_OK$2){this.result=common.flattenChunks(this.chunks)}this.chunks=[];this.err=status;this.msg=this.strm.msg};function deflate$1(input,options){const deflator=new Deflate$1(options);deflator.push(input,true);if(deflator.err){throw deflator.msg||messages[deflator.err]}return deflator.result}function deflateRaw$1(input,options){options=options||{};options.raw=true;return deflate$1(input,options)}function gzip$1(input,options){options=options||{};options.gzip=true;return deflate$1(input,options)}var Deflate_1$1=Deflate$1;var deflate_2=deflate$1;var deflateRaw_1$1=deflateRaw$1;var gzip_1$1=gzip$1;var constants$1=constants$2;var deflate_1$1={Deflate:Deflate_1$1,deflate:deflate_2,deflateRaw:deflateRaw_1$1,gzip:gzip_1$1,constants:constants$1};const BAD$1=16209;const TYPE$1=16191;var inffast=function inflate_fast(strm,start){let _in;let last;let _out;let beg;let end;let dmax;let wsize;let whave;let wnext;let s_window;let hold;let bits;let lcode;let dcode;let lmask;let dmask;let here;let op;let len;let dist;let from;let from_source;let input,output;const state=strm.state;_in=strm.next_in;input=strm.input;last=_in+(strm.avail_in-5);_out=strm.next_out;output=strm.output;beg=_out-(start-strm.avail_out);end=_out+(strm.avail_out-257);dmax=state.dmax;wsize=state.wsize;whave=state.whave;wnext=state.wnext;s_window=state.window;hold=state.hold;bits=state.bits;lcode=state.lencode;dcode=state.distcode;lmask=(1<<state.lenbits)-1;dmask=(1<<state.distbits)-1;top:do{if(bits<15){hold+=input[_in++]<<bits;bits+=8;hold+=input[_in++]<<bits;bits+=8}here=lcode[hold&lmask];dolen:for(;;){op=here>>>24;hold>>>=op;bits-=op;op=here>>>16&255;if(op===0){output[_out++]=here&65535}else if(op&16){len=here&65535;op&=15;if(op){if(bits<op){hold+=input[_in++]<<bits;bits+=8}len+=hold&(1<<op)-1;hold>>>=op;bits-=op}if(bits<15){hold+=input[_in++]<<bits;bits+=8;hold+=input[_in++]<<bits;bits+=8}here=dcode[hold&dmask];dodist:for(;;){op=here>>>24;hold>>>=op;bits-=op;op=here>>>16&255;if(op&16){dist=here&65535;op&=15;if(bits<op){hold+=input[_in++]<<bits;bits+=8;if(bits<op){hold+=input[_in++]<<bits;bits+=8}}dist+=hold&(1<<op)-1;if(dist>dmax){strm.msg="invalid distance too far back";state.mode=BAD$1;break top}hold>>>=op;bits-=op;op=_out-beg;if(dist>op){op=dist-op;if(op>whave){if(state.sane){strm.msg="invalid distance too far back";state.mode=BAD$1;break top}}from=0;from_source=s_window;if(wnext===0){from+=wsize-op;if(op<len){len-=op;do{output[_out++]=s_window[from++]}while(--op);from=_out-dist;from_source=output}}else if(wnext<op){from+=wsize+wnext-op;op-=wnext;if(op<len){len-=op;do{output[_out++]=s_window[from++]}while(--op);from=0;if(wnext<len){op=wnext;len-=op;do{output[_out++]=s_window[from++]}while(--op);from=_out-dist;from_source=output}}}else{from+=wnext-op;if(op<len){len-=op;do{output[_out++]=s_window[from++]}while(--op);from=_out-dist;from_source=output}}while(len>2){output[_out++]=from_source[from++];output[_out++]=from_source[from++];output[_out++]=from_source[from++];len-=3}if(len){output[_out++]=from_source[from++];if(len>1){output[_out++]=from_source[from++]}}}else{from=_out-dist;do{output[_out++]=output[from++];output[_out++]=output[from++];output[_out++]=output[from++];len-=3}while(len>2);if(len){output[_out++]=output[from++];if(len>1){output[_out++]=output[from++]}}}}else if((op&64)===0){here=dcode[(here&65535)+(hold&(1<<op)-1)];continue dodist}else{strm.msg="invalid distance code";state.mode=BAD$1;break top}break}}else if((op&64)===0){here=lcode[(here&65535)+(hold&(1<<op)-1)];continue dolen}else if(op&32){state.mode=TYPE$1;break top}else{strm.msg="invalid literal/length code";state.mode=BAD$1;break top}break}}while(_in<last&&_out<end);len=bits>>3;_in-=len;bits-=len<<3;hold&=(1<<bits)-1;strm.next_in=_in;strm.next_out=_out;strm.avail_in=_in<last?5+(last-_in):5-(_in-last);strm.avail_out=_out<end?257+(end-_out):257-(_out-end);state.hold=hold;state.bits=bits;return};const MAXBITS=15;const ENOUGH_LENS$1=852;const ENOUGH_DISTS$1=592;const CODES$1=0;const LENS$1=1;const DISTS$1=2;const lbase=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]);const lext=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]);const dbase=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]);const dext=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);const inflate_table=(type,lens,lens_index,codes,table,table_index,work,opts)=>{const bits=opts.bits;let len=0;let sym=0;let min=0,max=0;let root=0;let curr=0;let drop=0;let left=0;let used=0;let huff=0;let incr;let fill;let low;let mask;let next;let base=null;let match;const count=new Uint16Array(MAXBITS+1);const offs=new Uint16Array(MAXBITS+1);let extra=null;let here_bits,here_op,here_val;for(len=0;len<=MAXBITS;len++){count[len]=0}for(sym=0;sym<codes;sym++){count[lens[lens_index+sym]]++}root=bits;for(max=MAXBITS;max>=1;max--){if(count[max]!==0){break}}if(root>max){root=max}if(max===0){table[table_index++]=1<<24|64<<16|0;table[table_index++]=1<<24|64<<16|0;opts.bits=1;return 0}for(min=1;min<max;min++){if(count[min]!==0){break}}if(root<min){root=min}left=1;for(len=1;len<=MAXBITS;len++){left<<=1;left-=count[len];if(left<0){return-1}}if(left>0&&(type===CODES$1||max!==1)){return-1}offs[1]=0;for(len=1;len<MAXBITS;len++){offs[len+1]=offs[len]+count[len]}for(sym=0;sym<codes;sym++){if(lens[lens_index+sym]!==0){work[offs[lens[lens_index+sym]]++]=sym}}if(type===CODES$1){base=extra=work;match=20}else if(type===LENS$1){base=lbase;extra=lext;match=257}else{base=dbase;extra=dext;match=0}huff=0;sym=0;len=min;next=table_index;curr=root;drop=0;low=-1;used=1<<root;mask=used-1;if(type===LENS$1&&used>ENOUGH_LENS$1||type===DISTS$1&&used>ENOUGH_DISTS$1){return 1}for(;;){here_bits=len-drop;if(work[sym]+1<match){here_op=0;here_val=work[sym]}else if(work[sym]>=match){here_op=extra[work[sym]-match];here_val=base[work[sym]-match]}else{here_op=32+64;here_val=0}incr=1<<len-drop;fill=1<<curr;min=fill;do{fill-=incr;table[next+(huff>>drop)+fill]=here_bits<<24|here_op<<16|here_val|0}while(fill!==0);incr=1<<len-1;while(huff&incr){incr>>=1}if(incr!==0){huff&=incr-1;huff+=incr}else{huff=0}sym++;if(--count[len]===0){if(len===max){break}len=lens[lens_index+work[sym]]}if(len>root&&(huff&mask)!==low){if(drop===0){drop=root}next+=min;curr=len-drop;left=1<<curr;while(curr+drop<max){left-=count[curr+drop];if(left<=0){break}curr++;left<<=1}used+=1<<curr;if(type===LENS$1&&used>ENOUGH_LENS$1||type===DISTS$1&&used>ENOUGH_DISTS$1){return 1}low=huff&mask;table[low]=root<<24|curr<<16|next-table_index|0}}if(huff!==0){table[next+huff]=len-drop<<24|64<<16|0}opts.bits=root;return 0};var inftrees=inflate_table;const CODES=0;const LENS=1;const DISTS=2;const{Z_FINISH:Z_FINISH$1,Z_BLOCK,Z_TREES,Z_OK:Z_OK$1,Z_STREAM_END:Z_STREAM_END$1,Z_NEED_DICT:Z_NEED_DICT$1,Z_STREAM_ERROR:Z_STREAM_ERROR$1,Z_DATA_ERROR:Z_DATA_ERROR$1,Z_MEM_ERROR:Z_MEM_ERROR$1,Z_BUF_ERROR,Z_DEFLATED}=constants$2;const HEAD=16180;const FLAGS=16181;const TIME=16182;const OS=16183;const EXLEN=16184;const EXTRA=16185;const NAME=16186;const COMMENT=16187;const HCRC=16188;const DICTID=16189;const DICT=16190;const TYPE=16191;const TYPEDO=16192;const STORED=16193;const COPY_=16194;const COPY=16195;const TABLE=16196;const LENLENS=16197;const CODELENS=16198;const LEN_=16199;const LEN=16200;const LENEXT=16201;const DIST=16202;const DISTEXT=16203;const MATCH=16204;const LIT=16205;const CHECK=16206;const LENGTH=16207;const DONE=16208;const BAD=16209;const MEM=16210;const SYNC=16211;const ENOUGH_LENS=852;const ENOUGH_DISTS=592;const MAX_WBITS=15;const DEF_WBITS=MAX_WBITS;const zswap32=q=>{return(q>>>24&255)+(q>>>8&65280)+((q&65280)<<8)+((q&255)<<24)};function InflateState(){this.strm=null;this.mode=0;this.last=false;this.wrap=0;this.havedict=false;this.flags=0;this.dmax=0;this.check=0;this.total=0;this.head=null;this.wbits=0;this.wsize=0;this.whave=0;this.wnext=0;this.window=null;this.hold=0;this.bits=0;this.length=0;this.offset=0;this.extra=0;this.lencode=null;this.distcode=null;this.lenbits=0;this.distbits=0;this.ncode=0;this.nlen=0;this.ndist=0;this.have=0;this.next=null;this.lens=new Uint16Array(320);this.work=new Uint16Array(288);this.lendyn=null;this.distdyn=null;this.sane=0;this.back=0;this.was=0}const inflateStateCheck=strm=>{if(!strm){return 1}const state=strm.state;if(!state||state.strm!==strm||state.mode<HEAD||state.mode>SYNC){return 1}return 0};const inflateResetKeep=strm=>{if(inflateStateCheck(strm)){return Z_STREAM_ERROR$1}const state=strm.state;strm.total_in=strm.total_out=state.total=0;strm.msg="";if(state.wrap){strm.adler=state.wrap&1}state.mode=HEAD;state.last=0;state.havedict=0;state.flags=-1;state.dmax=32768;state.head=null;state.hold=0;state.bits=0;state.lencode=state.lendyn=new Int32Array(ENOUGH_LENS);state.distcode=state.distdyn=new Int32Array(ENOUGH_DISTS);state.sane=1;state.back=-1;return Z_OK$1};const inflateReset=strm=>{if(inflateStateCheck(strm)){return Z_STREAM_ERROR$1}const state=strm.state;state.wsize=0;state.whave=0;state.wnext=0;return inflateResetKeep(strm)};const inflateReset2=(strm,windowBits)=>{let wrap;if(inflateStateCheck(strm)){return Z_STREAM_ERROR$1}const state=strm.state;if(windowBits<0){wrap=0;windowBits=-windowBits}else{wrap=(windowBits>>4)+5;if(windowBits<48){windowBits&=15}}if(windowBits&&(windowBits<8||windowBits>15)){return Z_STREAM_ERROR$1}if(state.window!==null&&state.wbits!==windowBits){state.window=null}state.wrap=wrap;state.wbits=windowBits;return inflateReset(strm)};const inflateInit2=(strm,windowBits)=>{if(!strm){return Z_STREAM_ERROR$1}const state=new InflateState;strm.state=state;state.strm=strm;state.window=null;state.mode=HEAD;const ret=inflateReset2(strm,windowBits);if(ret!==Z_OK$1){strm.state=null}return ret};const inflateInit=strm=>{return inflateInit2(strm,DEF_WBITS)};let virgin=true;let lenfix,distfix;const fixedtables=state=>{if(virgin){lenfix=new Int32Array(512);distfix=new Int32Array(32);let sym=0;while(sym<144){state.lens[sym++]=8}while(sym<256){state.lens[sym++]=9}while(sym<280){state.lens[sym++]=7}while(sym<288){state.lens[sym++]=8}inftrees(LENS,state.lens,0,288,lenfix,0,state.work,{bits:9});sym=0;while(sym<32){state.lens[sym++]=5}inftrees(DISTS,state.lens,0,32,distfix,0,state.work,{bits:5});virgin=false}state.lencode=lenfix;state.lenbits=9;state.distcode=distfix;state.distbits=5};const updatewindow=(strm,src,end,copy)=>{let dist;const state=strm.state;if(state.window===null){state.wsize=1<<state.wbits;state.wnext=0;state.whave=0;state.window=new Uint8Array(state.wsize)}if(copy>=state.wsize){state.window.set(src.subarray(end-state.wsize,end),0);state.wnext=0;state.whave=state.wsize}else{dist=state.wsize-state.wnext;if(dist>copy){dist=copy}state.window.set(src.subarray(end-copy,end-copy+dist),state.wnext);copy-=dist;if(copy){state.window.set(src.subarray(end-copy,end),0);state.wnext=copy;state.whave=state.wsize}else{state.wnext+=dist;if(state.wnext===state.wsize){state.wnext=0}if(state.whave<state.wsize){state.whave+=dist}}}return 0};const inflate$2=(strm,flush)=>{let state;let input,output;let next;let put;let have,left;let hold;let bits;let _in,_out;let copy;let from;let from_source;let here=0;let here_bits,here_op,here_val;let last_bits,last_op,last_val;let len;let ret;const hbuf=new Uint8Array(4);let opts;let n;const order=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(inflateStateCheck(strm)||!strm.output||!strm.input&&strm.avail_in!==0){return Z_STREAM_ERROR$1}state=strm.state;if(state.mode===TYPE){state.mode=TYPEDO}put=strm.next_out;output=strm.output;left=strm.avail_out;next=strm.next_in;input=strm.input;have=strm.avail_in;hold=state.hold;bits=state.bits;_in=have;_out=left;ret=Z_OK$1;inf_leave:for(;;){switch(state.mode){case HEAD:if(state.wrap===0){state.mode=TYPEDO;break}while(bits<16){if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}if(state.wrap&2&&hold===35615){if(state.wbits===0){state.wbits=15}state.check=0;hbuf[0]=hold&255;hbuf[1]=hold>>>8&255;state.check=crc32_1(state.check,hbuf,2,0);hold=0;bits=0;state.mode=FLAGS;break}if(state.head){state.head.done=false}if(!(state.wrap&1)||(((hold&255)<<8)+(hold>>8))%31){strm.msg="incorrect header check";state.mode=BAD;break}if((hold&15)!==Z_DEFLATED){strm.msg="unknown compression method";state.mode=BAD;break}hold>>>=4;bits-=4;len=(hold&15)+8;if(state.wbits===0){state.wbits=len}if(len>15||len>state.wbits){strm.msg="invalid window size";state.mode=BAD;break}state.dmax=1<<state.wbits;state.flags=0;strm.adler=state.check=1;state.mode=hold&512?DICTID:TYPE;hold=0;bits=0;break;case FLAGS:while(bits<16){if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}state.flags=hold;if((state.flags&255)!==Z_DEFLATED){strm.msg="unknown compression method";state.mode=BAD;break}if(state.flags&57344){strm.msg="unknown header flags set";state.mode=BAD;break}if(state.head){state.head.text=hold>>8&1}if(state.flags&512&&state.wrap&4){hbuf[0]=hold&255;hbuf[1]=hold>>>8&255;state.check=crc32_1(state.check,hbuf,2,0)}hold=0;bits=0;state.mode=TIME;case TIME:while(bits<32){if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}if(state.head){state.head.time=hold}if(state.flags&512&&state.wrap&4){hbuf[0]=hold&255;hbuf[1]=hold>>>8&255;hbuf[2]=hold>>>16&255;hbuf[3]=hold>>>24&255;state.check=crc32_1(state.check,hbuf,4,0)}hold=0;bits=0;state.mode=OS;case OS:while(bits<16){if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}if(state.head){state.head.xflags=hold&255;state.head.os=hold>>8}if(state.flags&512&&state.wrap&4){hbuf[0]=hold&255;hbuf[1]=hold>>>8&255;state.check=crc32_1(state.check,hbuf,2,0)}hold=0;bits=0;state.mode=EXLEN;case EXLEN:if(state.flags&1024){while(bits<16){if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}state.length=hold;if(state.head){state.head.extra_len=hold}if(state.flags&512&&state.wrap&4){hbuf[0]=hold&255;hbuf[1]=hold>>>8&255;state.check=crc32_1(state.check,hbuf,2,0)}hold=0;bits=0}else if(state.head){state.head.extra=null}state.mode=EXTRA;case EXTRA:if(state.flags&1024){copy=state.length;if(copy>have){copy=have}if(copy){if(state.head){len=state.head.extra_len-state.length;if(!state.head.extra){state.head.extra=new Uint8Array(state.head.extra_len)}state.head.extra.set(input.subarray(next,next+copy),len)}if(state.flags&512&&state.wrap&4){state.check=crc32_1(state.check,input,copy,next)}have-=copy;next+=copy;state.length-=copy}if(state.length){break inf_leave}}state.length=0;state.mode=NAME;case NAME:if(state.flags&2048){if(have===0){break inf_leave}copy=0;do{len=input[next+copy++];if(state.head&&len&&state.length<65536){state.head.name+=String.fromCharCode(len)}}while(len&&copy<have);if(state.flags&512&&state.wrap&4){state.check=crc32_1(state.check,input,copy,next)}have-=copy;next+=copy;if(len){break inf_leave}}else if(state.head){state.head.name=null}state.length=0;state.mode=COMMENT;case COMMENT:if(state.flags&4096){if(have===0){break inf_leave}copy=0;do{len=input[next+copy++];if(state.head&&len&&state.length<65536){state.head.comment+=String.fromCharCode(len)}}while(len&&copy<have);if(state.flags&512&&state.wrap&4){state.check=crc32_1(state.check,input,copy,next)}have-=copy;next+=copy;if(len){break inf_leave}}else if(state.head){state.head.comment=null}state.mode=HCRC;case HCRC:if(state.flags&512){while(bits<16){if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}if(state.wrap&4&&hold!==(state.check&65535)){strm.msg="header crc mismatch";state.mode=BAD;break}hold=0;bits=0}if(state.head){state.head.hcrc=state.flags>>9&1;state.head.done=true}strm.adler=state.check=0;state.mode=TYPE;break;case DICTID:while(bits<32){if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}strm.adler=state.check=zswap32(hold);hold=0;bits=0;state.mode=DICT;case DICT:if(state.havedict===0){strm.next_out=put;strm.avail_out=left;strm.next_in=next;strm.avail_in=have;state.hold=hold;state.bits=bits;return Z_NEED_DICT$1}strm.adler=state.check=1;state.mode=TYPE;case TYPE:if(flush===Z_BLOCK||flush===Z_TREES){break inf_leave}case TYPEDO:if(state.last){hold>>>=bits&7;bits-=bits&7;state.mode=CHECK;break}while(bits<3){if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}state.last=hold&1;hold>>>=1;bits-=1;switch(hold&3){case 0:state.mode=STORED;break;case 1:fixedtables(state);state.mode=LEN_;if(flush===Z_TREES){hold>>>=2;bits-=2;break inf_leave}break;case 2:state.mode=TABLE;break;case 3:strm.msg="invalid block type";state.mode=BAD}hold>>>=2;bits-=2;break;case STORED:hold>>>=bits&7;bits-=bits&7;while(bits<32){if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}if((hold&65535)!==(hold>>>16^65535)){strm.msg="invalid stored block lengths";state.mode=BAD;break}state.length=hold&65535;hold=0;bits=0;state.mode=COPY_;if(flush===Z_TREES){break inf_leave}case COPY_:state.mode=COPY;case COPY:copy=state.length;if(copy){if(copy>have){copy=have}if(copy>left){copy=left}if(copy===0){break inf_leave}output.set(input.subarray(next,next+copy),put);have-=copy;next+=copy;left-=copy;put+=copy;state.length-=copy;break}state.mode=TYPE;break;case TABLE:while(bits<14){if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}state.nlen=(hold&31)+257;hold>>>=5;bits-=5;state.ndist=(hold&31)+1;hold>>>=5;bits-=5;state.ncode=(hold&15)+4;hold>>>=4;bits-=4;if(state.nlen>286||state.ndist>30){strm.msg="too many length or distance symbols";state.mode=BAD;break}state.have=0;state.mode=LENLENS;case LENLENS:while(state.have<state.ncode){while(bits<3){if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}state.lens[order[state.have++]]=hold&7;hold>>>=3;bits-=3}while(state.have<19){state.lens[order[state.have++]]=0}state.lencode=state.lendyn;state.lenbits=7;opts={bits:state.lenbits};ret=inftrees(CODES,state.lens,0,19,state.lencode,0,state.work,opts);state.lenbits=opts.bits;if(ret){strm.msg="invalid code lengths set";state.mode=BAD;break}state.have=0;state.mode=CODELENS;case CODELENS:while(state.have<state.nlen+state.ndist){for(;;){here=state.lencode[hold&(1<<state.lenbits)-1];here_bits=here>>>24;here_op=here>>>16&255;here_val=here&65535;if(here_bits<=bits){break}if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}if(here_val<16){hold>>>=here_bits;bits-=here_bits;state.lens[state.have++]=here_val}else{if(here_val===16){n=here_bits+2;while(bits<n){if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}hold>>>=here_bits;bits-=here_bits;if(state.have===0){strm.msg="invalid bit length repeat";state.mode=BAD;break}len=state.lens[state.have-1];copy=3+(hold&3);hold>>>=2;bits-=2}else if(here_val===17){n=here_bits+3;while(bits<n){if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}hold>>>=here_bits;bits-=here_bits;len=0;copy=3+(hold&7);hold>>>=3;bits-=3}else{n=here_bits+7;while(bits<n){if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}hold>>>=here_bits;bits-=here_bits;len=0;copy=11+(hold&127);hold>>>=7;bits-=7}if(state.have+copy>state.nlen+state.ndist){strm.msg="invalid bit length repeat";state.mode=BAD;break}while(copy--){state.lens[state.have++]=len}}}if(state.mode===BAD){break}if(state.lens[256]===0){strm.msg="invalid code -- missing end-of-block";state.mode=BAD;break}state.lenbits=9;opts={bits:state.lenbits};ret=inftrees(LENS,state.lens,0,state.nlen,state.lencode,0,state.work,opts);state.lenbits=opts.bits;if(ret){strm.msg="invalid literal/lengths set";state.mode=BAD;break}state.distbits=6;state.distcode=state.distdyn;opts={bits:state.distbits};ret=inftrees(DISTS,state.lens,state.nlen,state.ndist,state.distcode,0,state.work,opts);state.distbits=opts.bits;if(ret){strm.msg="invalid distances set";state.mode=BAD;break}state.mode=LEN_;if(flush===Z_TREES){break inf_leave}case LEN_:state.mode=LEN;case LEN:if(have>=6&&left>=258){strm.next_out=put;strm.avail_out=left;strm.next_in=next;strm.avail_in=have;state.hold=hold;state.bits=bits;inffast(strm,_out);put=strm.next_out;output=strm.output;left=strm.avail_out;next=strm.next_in;input=strm.input;have=strm.avail_in;hold=state.hold;bits=state.bits;if(state.mode===TYPE){state.back=-1}break}state.back=0;for(;;){here=state.lencode[hold&(1<<state.lenbits)-1];here_bits=here>>>24;here_op=here>>>16&255;here_val=here&65535;if(here_bits<=bits){break}if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}if(here_op&&(here_op&240)===0){last_bits=here_bits;last_op=here_op;last_val=here_val;for(;;){here=state.lencode[last_val+((hold&(1<<last_bits+last_op)-1)>>last_bits)];here_bits=here>>>24;here_op=here>>>16&255;here_val=here&65535;if(last_bits+here_bits<=bits){break}if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}hold>>>=last_bits;bits-=last_bits;state.back+=last_bits}hold>>>=here_bits;bits-=here_bits;state.back+=here_bits;state.length=here_val;if(here_op===0){state.mode=LIT;break}if(here_op&32){state.back=-1;state.mode=TYPE;break}if(here_op&64){strm.msg="invalid literal/length code";state.mode=BAD;break}state.extra=here_op&15;state.mode=LENEXT;case LENEXT:if(state.extra){n=state.extra;while(bits<n){if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}state.length+=hold&(1<<state.extra)-1;hold>>>=state.extra;bits-=state.extra;state.back+=state.extra}state.was=state.length;state.mode=DIST;case DIST:for(;;){here=state.distcode[hold&(1<<state.distbits)-1];here_bits=here>>>24;here_op=here>>>16&255;here_val=here&65535;if(here_bits<=bits){break}if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}if((here_op&240)===0){last_bits=here_bits;last_op=here_op;last_val=here_val;for(;;){here=state.distcode[last_val+((hold&(1<<last_bits+last_op)-1)>>last_bits)];here_bits=here>>>24;here_op=here>>>16&255;here_val=here&65535;if(last_bits+here_bits<=bits){break}if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}hold>>>=last_bits;bits-=last_bits;state.back+=last_bits}hold>>>=here_bits;bits-=here_bits;state.back+=here_bits;if(here_op&64){strm.msg="invalid distance code";state.mode=BAD;break}state.offset=here_val;state.extra=here_op&15;state.mode=DISTEXT;case DISTEXT:if(state.extra){n=state.extra;while(bits<n){if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}state.offset+=hold&(1<<state.extra)-1;hold>>>=state.extra;bits-=state.extra;state.back+=state.extra}if(state.offset>state.dmax){strm.msg="invalid distance too far back";state.mode=BAD;break}state.mode=MATCH;case MATCH:if(left===0){break inf_leave}copy=_out-left;if(state.offset>copy){copy=state.offset-copy;if(copy>state.whave){if(state.sane){strm.msg="invalid distance too far back";state.mode=BAD;break}}if(copy>state.wnext){copy-=state.wnext;from=state.wsize-copy}else{from=state.wnext-copy}if(copy>state.length){copy=state.length}from_source=state.window}else{from_source=output;from=put-state.offset;copy=state.length}if(copy>left){copy=left}left-=copy;state.length-=copy;do{output[put++]=from_source[from++]}while(--copy);if(state.length===0){state.mode=LEN}break;case LIT:if(left===0){break inf_leave}output[put++]=state.length;left--;state.mode=LEN;break;case CHECK:if(state.wrap){while(bits<32){if(have===0){break inf_leave}have--;hold|=input[next++]<<bits;bits+=8}_out-=left;strm.total_out+=_out;state.total+=_out;if(state.wrap&4&&_out){strm.adler=state.check=state.flags?crc32_1(state.check,output,_out,put-_out):adler32_1(state.check,output,_out,put-_out)}_out=left;if(state.wrap&4&&(state.flags?hold:zswap32(hold))!==state.check){strm.msg="incorrect data check";state.mode=BAD;break}hold=0;bits=0}state.mode=LENGTH;case LENGTH:if(state.wrap&&state.flags){while(bits<32){if(have===0){break inf_leave}have--;hold+=input[next++]<<bits;bits+=8}if(state.wrap&4&&hold!==(state.total&4294967295)){strm.msg="incorrect length check";state.mode=BAD;break}hold=0;bits=0}state.mode=DONE;case DONE:ret=Z_STREAM_END$1;break inf_leave;case BAD:ret=Z_DATA_ERROR$1;break inf_leave;case MEM:return Z_MEM_ERROR$1;case SYNC:default:return Z_STREAM_ERROR$1}}strm.next_out=put;strm.avail_out=left;strm.next_in=next;strm.avail_in=have;state.hold=hold;state.bits=bits;if(state.wsize||_out!==strm.avail_out&&state.mode<BAD&&(state.mode<CHECK||flush!==Z_FINISH$1)){if(updatewindow(strm,strm.output,strm.next_out,_out-strm.avail_out));}_in-=strm.avail_in;_out-=strm.avail_out;strm.total_in+=_in;strm.total_out+=_out;state.total+=_out;if(state.wrap&4&&_out){strm.adler=state.check=state.flags?crc32_1(state.check,output,_out,strm.next_out-_out):adler32_1(state.check,output,_out,strm.next_out-_out)}strm.data_type=state.bits+(state.last?64:0)+(state.mode===TYPE?128:0)+(state.mode===LEN_||state.mode===COPY_?256:0);if((_in===0&&_out===0||flush===Z_FINISH$1)&&ret===Z_OK$1){ret=Z_BUF_ERROR}return ret};const inflateEnd=strm=>{if(inflateStateCheck(strm)){return Z_STREAM_ERROR$1}let state=strm.state;if(state.window){state.window=null}strm.state=null;return Z_OK$1};const inflateGetHeader=(strm,head)=>{if(inflateStateCheck(strm)){return Z_STREAM_ERROR$1}const state=strm.state;if((state.wrap&2)===0){return Z_STREAM_ERROR$1}state.head=head;head.done=false;return Z_OK$1};const inflateSetDictionary=(strm,dictionary)=>{const dictLength=dictionary.length;let state;let dictid;let ret;if(inflateStateCheck(strm)){return Z_STREAM_ERROR$1}state=strm.state;if(state.wrap!==0&&state.mode!==DICT){return Z_STREAM_ERROR$1}if(state.mode===DICT){dictid=1;dictid=adler32_1(dictid,dictionary,dictLength,0);if(dictid!==state.check){return Z_DATA_ERROR$1}}ret=updatewindow(strm,dictionary,dictLength,dictLength);if(ret){state.mode=MEM;return Z_MEM_ERROR$1}state.havedict=1;return Z_OK$1};var inflateReset_1=inflateReset;var inflateReset2_1=inflateReset2;var inflateResetKeep_1=inflateResetKeep;var inflateInit_1=inflateInit;var inflateInit2_1=inflateInit2;var inflate_2$1=inflate$2;var inflateEnd_1=inflateEnd;var inflateGetHeader_1=inflateGetHeader;var inflateSetDictionary_1=inflateSetDictionary;var inflateInfo="pako inflate (from Nodeca project)";var inflate_1$2={inflateReset:inflateReset_1,inflateReset2:inflateReset2_1,inflateResetKeep:inflateResetKeep_1,inflateInit:inflateInit_1,inflateInit2:inflateInit2_1,inflate:inflate_2$1,inflateEnd:inflateEnd_1,inflateGetHeader:inflateGetHeader_1,inflateSetDictionary:inflateSetDictionary_1,inflateInfo:inflateInfo};function GZheader(){this.text=0;this.time=0;this.xflags=0;this.os=0;this.extra=null;this.extra_len=0;this.name="";this.comment="";this.hcrc=0;this.done=false}var gzheader=GZheader;const toString=Object.prototype.toString;const{Z_NO_FLUSH,Z_FINISH,Z_OK,Z_STREAM_END,Z_NEED_DICT,Z_STREAM_ERROR,Z_DATA_ERROR,Z_MEM_ERROR}=constants$2;function Inflate$1(options){this.options=common.assign({chunkSize:1024*64,windowBits:15,to:""},options||{});const opt=this.options;if(opt.raw&&opt.windowBits>=0&&opt.windowBits<16){opt.windowBits=-opt.windowBits;if(opt.windowBits===0){opt.windowBits=-15}}if(opt.windowBits>=0&&opt.windowBits<16&&!(options&&options.windowBits)){opt.windowBits+=32}if(opt.windowBits>15&&opt.windowBits<48){if((opt.windowBits&15)===0){opt.windowBits|=15}}this.err=0;this.msg="";this.ended=false;this.chunks=[];this.strm=new zstream;this.strm.avail_out=0;let status=inflate_1$2.inflateInit2(this.strm,opt.windowBits);if(status!==Z_OK){throw new Error(messages[status])}this.header=new gzheader;inflate_1$2.inflateGetHeader(this.strm,this.header);if(opt.dictionary){if(typeof opt.dictionary==="string"){opt.dictionary=strings.string2buf(opt.dictionary)}else if(toString.call(opt.dictionary)==="[object ArrayBuffer]"){opt.dictionary=new Uint8Array(opt.dictionary)}if(opt.raw){status=inflate_1$2.inflateSetDictionary(this.strm,opt.dictionary);if(status!==Z_OK){throw new Error(messages[status])}}}}Inflate$1.prototype.push=function(data,flush_mode){const strm=this.strm;const chunkSize=this.options.chunkSize;const dictionary=this.options.dictionary;let status,_flush_mode,last_avail_out;if(this.ended)return false;if(flush_mode===~~flush_mode)_flush_mode=flush_mode;else _flush_mode=flush_mode===true?Z_FINISH:Z_NO_FLUSH;if(toString.call(data)==="[object ArrayBuffer]"){strm.input=new Uint8Array(data)}else{strm.input=data}strm.next_in=0;strm.avail_in=strm.input.length;for(;;){if(strm.avail_out===0){strm.output=new Uint8Array(chunkSize);strm.next_out=0;strm.avail_out=chunkSize}status=inflate_1$2.inflate(strm,_flush_mode);if(status===Z_NEED_DICT&&dictionary){status=inflate_1$2.inflateSetDictionary(strm,dictionary);if(status===Z_OK){status=inflate_1$2.inflate(strm,_flush_mode)}else if(status===Z_DATA_ERROR){status=Z_NEED_DICT}}while(strm.avail_in>0&&status===Z_STREAM_END&&strm.state.wrap>0&&data[strm.next_in]!==0){inflate_1$2.inflateReset(strm);status=inflate_1$2.inflate(strm,_flush_mode)}switch(status){case Z_STREAM_ERROR:case Z_DATA_ERROR:case Z_NEED_DICT:case Z_MEM_ERROR:this.onEnd(status);this.ended=true;return false}last_avail_out=strm.avail_out;if(strm.next_out){if(strm.avail_out===0||status===Z_STREAM_END){if(this.options.to==="string"){let next_out_utf8=strings.utf8border(strm.output,strm.next_out);let tail=strm.next_out-next_out_utf8;let utf8str=strings.buf2string(strm.output,next_out_utf8);strm.next_out=tail;strm.avail_out=chunkSize-tail;if(tail)strm.output.set(strm.output.subarray(next_out_utf8,next_out_utf8+tail),0);this.onData(utf8str)}else{this.onData(strm.output.length===strm.next_out?strm.output:strm.output.subarray(0,strm.next_out))}}}if(status===Z_OK&&last_avail_out===0)continue;if(status===Z_STREAM_END){status=inflate_1$2.inflateEnd(this.strm);this.onEnd(status);this.ended=true;return true}if(strm.avail_in===0)break}return true};Inflate$1.prototype.onData=function(chunk){this.chunks.push(chunk)};Inflate$1.prototype.onEnd=function(status){if(status===Z_OK){if(this.options.to==="string"){this.result=this.chunks.join("")}else{this.result=common.flattenChunks(this.chunks)}}this.chunks=[];this.err=status;this.msg=this.strm.msg};function inflate$1(input,options){const inflator=new Inflate$1(options);inflator.push(input);if(inflator.err)throw inflator.msg||messages[inflator.err];return inflator.result}function inflateRaw$1(input,options){options=options||{};options.raw=true;return inflate$1(input,options)}var Inflate_1$1=Inflate$1;var inflate_2=inflate$1;var inflateRaw_1$1=inflateRaw$1;var ungzip$1=inflate$1;var constants=constants$2;var inflate_1$1={Inflate:Inflate_1$1,inflate:inflate_2,inflateRaw:inflateRaw_1$1,ungzip:ungzip$1,constants:constants};const{Deflate,deflate,deflateRaw,gzip}=deflate_1$1;const{Inflate,inflate,inflateRaw,ungzip}=inflate_1$1;var Deflate_1=Deflate;var deflate_1=deflate;var deflateRaw_1=deflateRaw;var gzip_1=gzip;var Inflate_1=Inflate;var inflate_1=inflate;var inflateRaw_1=inflateRaw;var ungzip_1=ungzip;var constants_1=constants$2;var pako$1={Deflate:Deflate_1,deflate:deflate_1,deflateRaw:deflateRaw_1,gzip:gzip_1,Inflate:Inflate_1,inflate:inflate_1,inflateRaw:inflateRaw_1,ungzip:ungzip_1,constants:constants_1};function addgRPCHeader({header,body},encoding=undefined){console.log(`☑️ Add gRPC Header`,"");const flag=encoding=="gzip"?1:encoding=="identity"?0:encoding==undefined?0:header?.[0]??0;const checksum=Checksum(body.length);if(encoding=="gzip")body=pako.gzip(body);let rawBody=new Uint8Array(header.length+body.length);rawBody.set([flag],0);rawBody.set(checksum,1);rawBody.set(body,5);console.log(`✅ Add gRPC Header`,"");return rawBody;function Checksum(num){let arr=new ArrayBuffer(4);let view=new DataView(arr);view.setUint32(0,num,false);return new Uint8Array(arr)}}function typeofJsonValue(value){let t=typeof value;if(t=="object"){if(Array.isArray(value))return"array";if(value===null)return"null"}return t}function isJsonObject(value){return value!==null&&typeof value=="object"&&!Array.isArray(value)}let encTable="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");let decTable=[];for(let i=0;i<encTable.length;i++)decTable[encTable[i].charCodeAt(0)]=i;decTable["-".charCodeAt(0)]=encTable.indexOf("+");decTable["_".charCodeAt(0)]=encTable.indexOf("/");function base64decode(base64Str){let es=base64Str.length*3/4;if(base64Str[base64Str.length-2]=="=")es-=2;else if(base64Str[base64Str.length-1]=="=")es-=1;let bytes=new Uint8Array(es),bytePos=0,groupPos=0,b,p=0;for(let i=0;i<base64Str.length;i++){b=decTable[base64Str.charCodeAt(i)];if(b===undefined){switch(base64Str[i]){case"=":groupPos=0;case"\n":case"\r":case"\t":case" ":continue;default:throw Error(`invalid base64 string.`)}}switch(groupPos){case 0:p=b;groupPos=1;break;case 1:bytes[bytePos++]=p<<2|(b&48)>>4;p=b;groupPos=2;break;case 2:bytes[bytePos++]=(p&15)<<4|(b&60)>>2;p=b;groupPos=3;break;case 3:bytes[bytePos++]=(p&3)<<6|b;groupPos=0;break}}if(groupPos==1)throw Error(`invalid base64 string.`);return bytes.subarray(0,bytePos)}function base64encode(bytes){let base64="",groupPos=0,b,p=0;for(let i=0;i<bytes.length;i++){b=bytes[i];switch(groupPos){case 0:base64+=encTable[b>>2];p=(b&3)<<4;groupPos=1;break;case 1:base64+=encTable[p|b>>4];p=(b&15)<<2;groupPos=2;break;case 2:base64+=encTable[p|b>>6];base64+=encTable[b&63];groupPos=0;break}}if(groupPos){base64+=encTable[p];base64+="=";if(groupPos==1)base64+="="}return base64}var UnknownFieldHandler;(function(UnknownFieldHandler){UnknownFieldHandler.symbol=Symbol["for"]("protobuf-ts/unknown");UnknownFieldHandler.onRead=(typeName,message,fieldNo,wireType,data)=>{let container=is(message)?message[UnknownFieldHandler.symbol]:message[UnknownFieldHandler.symbol]=[];container.push({no:fieldNo,wireType:wireType,data:data})};UnknownFieldHandler.onWrite=(typeName,message,writer)=>{for(let{no,wireType,data}of UnknownFieldHandler.list(message))writer.tag(no,wireType).raw(data)};UnknownFieldHandler.list=(message,fieldNo)=>{if(is(message)){let all=message[UnknownFieldHandler.symbol];return fieldNo?all.filter(uf=>uf.no==fieldNo):all}return[]};UnknownFieldHandler.last=(message,fieldNo)=>UnknownFieldHandler.list(message,fieldNo).slice(-1)[0];const is=message=>message&&Array.isArray(message[UnknownFieldHandler.symbol])})(UnknownFieldHandler||(UnknownFieldHandler={}));var WireType;(function(WireType){WireType[WireType["Varint"]=0]="Varint";WireType[WireType["Bit64"]=1]="Bit64";WireType[WireType["LengthDelimited"]=2]="LengthDelimited";WireType[WireType["StartGroup"]=3]="StartGroup";WireType[WireType["EndGroup"]=4]="EndGroup";WireType[WireType["Bit32"]=5]="Bit32"})(WireType||(WireType={}));function varint64read(){let lowBits=0;let highBits=0;for(let shift=0;shift<28;shift+=7){let b=this.buf[this.pos++];lowBits|=(b&127)<<shift;if((b&128)==0){this.assertBounds();return[lowBits,highBits]}}let middleByte=this.buf[this.pos++];lowBits|=(middleByte&15)<<28;highBits=(middleByte&112)>>4;if((middleByte&128)==0){this.assertBounds();return[lowBits,highBits]}for(let shift=3;shift<=31;shift+=7){let b=this.buf[this.pos++];highBits|=(b&127)<<shift;if((b&128)==0){this.assertBounds();return[lowBits,highBits]}}throw new Error("invalid varint")}function varint64write(lo,hi,bytes){for(let i=0;i<28;i=i+7){const shift=lo>>>i;const hasNext=!(shift>>>7==0&&hi==0);const byte=(hasNext?shift|128:shift)&255;bytes.push(byte);if(!hasNext){return}}const splitBits=lo>>>28&15|(hi&7)<<4;const hasMoreBits=!(hi>>3==0);bytes.push((hasMoreBits?splitBits|128:splitBits)&255);if(!hasMoreBits){return}for(let i=3;i<31;i=i+7){const shift=hi>>>i;const hasNext=!(shift>>>7==0);const byte=(hasNext?shift|128:shift)&255;bytes.push(byte);if(!hasNext){return}}bytes.push(hi>>>31&1)}const TWO_PWR_32_DBL$1=(1<<16)*(1<<16);function int64fromString(dec){let minus=dec[0]=="-";if(minus)dec=dec.slice(1);const base=1e6;let lowBits=0;let highBits=0;function add1e6digit(begin,end){const digit1e6=Number(dec.slice(begin,end));highBits*=base;lowBits=lowBits*base+digit1e6;if(lowBits>=TWO_PWR_32_DBL$1){highBits=highBits+(lowBits/TWO_PWR_32_DBL$1|0);lowBits=lowBits%TWO_PWR_32_DBL$1}}add1e6digit(-24,-18);add1e6digit(-18,-12);add1e6digit(-12,-6);add1e6digit(-6);return[minus,lowBits,highBits]}function int64toString(bitsLow,bitsHigh){if(bitsHigh>>>0<=2097151){return""+(TWO_PWR_32_DBL$1*bitsHigh+(bitsLow>>>0))}let low=bitsLow&16777215;let mid=(bitsLow>>>24|bitsHigh<<8)>>>0&16777215;let high=bitsHigh>>16&65535;let digitA=low+mid*6777216+high*6710656;let digitB=mid+high*8147497;let digitC=high*2;let base=1e7;if(digitA>=base){digitB+=Math.floor(digitA/base);digitA%=base}if(digitB>=base){digitC+=Math.floor(digitB/base);digitB%=base}function decimalFrom1e7(digit1e7,needLeadingZeros){let partial=digit1e7?String(digit1e7):"";if(needLeadingZeros){return"0000000".slice(partial.length)+partial}return partial}return decimalFrom1e7(digitC,0)+decimalFrom1e7(digitB,digitC)+decimalFrom1e7(digitA,1)}function varint32write(value,bytes){if(value>=0){while(value>127){bytes.push(value&127|128);value=value>>>7}bytes.push(value)}else{for(let i=0;i<9;i++){bytes.push(value&127|128);value=value>>7}bytes.push(1)}}function varint32read(){let b=this.buf[this.pos++];let result=b&127;if((b&128)==0){this.assertBounds();return result}b=this.buf[this.pos++];result|=(b&127)<<7;if((b&128)==0){this.assertBounds();return result}b=this.buf[this.pos++];result|=(b&127)<<14;if((b&128)==0){this.assertBounds();return result}b=this.buf[this.pos++];result|=(b&127)<<21;if((b&128)==0){this.assertBounds();return result}b=this.buf[this.pos++];result|=(b&15)<<28;for(let readBytes=5;(b&128)!==0&&readBytes<10;readBytes++)b=this.buf[this.pos++];if((b&128)!=0)throw new Error("invalid varint");this.assertBounds();return result>>>0}let BI;function detectBi(){const dv=new DataView(new ArrayBuffer(8));const ok=globalThis.BigInt!==undefined&&typeof dv.getBigInt64==="function"&&typeof dv.getBigUint64==="function"&&typeof dv.setBigInt64==="function"&&typeof dv.setBigUint64==="function";BI=ok?{MIN:BigInt("-9223372036854775808"),MAX:BigInt("9223372036854775807"),UMIN:BigInt("0"),UMAX:BigInt("18446744073709551615"),C:BigInt,V:dv}:undefined}detectBi();function assertBi(bi){if(!bi)throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support")}const RE_DECIMAL_STR=/^-?[0-9]+$/;const TWO_PWR_32_DBL=4294967296;const HALF_2_PWR_32=2147483648;class SharedPbLong{constructor(lo,hi){this.lo=lo|0;this.hi=hi|0}isZero(){return this.lo==0&&this.hi==0}toNumber(){let result=this.hi*TWO_PWR_32_DBL+(this.lo>>>0);if(!Number.isSafeInteger(result))throw new Error("cannot convert to safe number");return result}}class PbULong extends SharedPbLong{static from(value){if(BI)switch(typeof value){case"string":if(value=="0")return this.ZERO;if(value=="")throw new Error("string is no integer");value=BI.C(value);case"number":if(value===0)return this.ZERO;value=BI.C(value);case"bigint":if(!value)return this.ZERO;if(value<BI.UMIN)throw new Error("signed value for ulong");if(value>BI.UMAX)throw new Error("ulong too large");BI.V.setBigUint64(0,value,true);return new PbULong(BI.V.getInt32(0,true),BI.V.getInt32(4,true))}else switch(typeof value){case"string":if(value=="0")return this.ZERO;value=value.trim();if(!RE_DECIMAL_STR.test(value))throw new Error("string is no integer");let[minus,lo,hi]=int64fromString(value);if(minus)throw new Error("signed value for ulong");return new PbULong(lo,hi);case"number":if(value==0)return this.ZERO;if(!Number.isSafeInteger(value))throw new Error("number is no integer");if(value<0)throw new Error("signed value for ulong");return new PbULong(value,value/TWO_PWR_32_DBL)}throw new Error("unknown value "+typeof value)}toString(){return BI?this.toBigInt().toString():int64toString(this.lo,this.hi)}toBigInt(){assertBi(BI);BI.V.setInt32(0,this.lo,true);BI.V.setInt32(4,this.hi,true);return BI.V.getBigUint64(0,true)}}PbULong.ZERO=new PbULong(0,0);class PbLong extends SharedPbLong{static from(value){if(BI)switch(typeof value){case"string":if(value=="0")return this.ZERO;if(value=="")throw new Error("string is no integer");value=BI.C(value);case"number":if(value===0)return this.ZERO;value=BI.C(value);case"bigint":if(!value)return this.ZERO;if(value<BI.MIN)throw new Error("signed long too small");if(value>BI.MAX)throw new Error("signed long too large");BI.V.setBigInt64(0,value,true);return new PbLong(BI.V.getInt32(0,true),BI.V.getInt32(4,true))}else switch(typeof value){case"string":if(value=="0")return this.ZERO;value=value.trim();if(!RE_DECIMAL_STR.test(value))throw new Error("string is no integer");let[minus,lo,hi]=int64fromString(value);if(minus){if(hi>HALF_2_PWR_32||hi==HALF_2_PWR_32&&lo!=0)throw new Error("signed long too small")}else if(hi>=HALF_2_PWR_32)throw new Error("signed long too large");let pbl=new PbLong(lo,hi);return minus?pbl.negate():pbl;case"number":if(value==0)return this.ZERO;if(!Number.isSafeInteger(value))throw new Error("number is no integer");return value>0?new PbLong(value,value/TWO_PWR_32_DBL):new PbLong(-value,-value/TWO_PWR_32_DBL).negate()}throw new Error("unknown value "+typeof value)}isNegative(){return(this.hi&HALF_2_PWR_32)!==0}negate(){let hi=~this.hi,lo=this.lo;if(lo)lo=~lo+1;else hi+=1;return new PbLong(lo,hi)}toString(){if(BI)return this.toBigInt().toString();if(this.isNegative()){let n=this.negate();return"-"+int64toString(n.lo,n.hi)}return int64toString(this.lo,this.hi)}toBigInt(){assertBi(BI);BI.V.setInt32(0,this.lo,true);BI.V.setInt32(4,this.hi,true);return BI.V.getBigInt64(0,true)}}PbLong.ZERO=new PbLong(0,0);const defaultsRead$1={readUnknownField:true,readerFactory:bytes=>new BinaryReader(bytes)};function binaryReadOptions(options){return options?Object.assign(Object.assign({},defaultsRead$1),options):defaultsRead$1}class BinaryReader{constructor(buf,textDecoder){this.varint64=varint64read;this.uint32=varint32read;this.buf=buf;this.len=buf.length;this.pos=0;this.view=new DataView(buf.buffer,buf.byteOffset,buf.byteLength);this.textDecoder=textDecoder!==null&&textDecoder!==void 0?textDecoder:new TextDecoder("utf-8",{fatal:true,ignoreBOM:true})}tag(){let tag=this.uint32(),fieldNo=tag>>>3,wireType=tag&7;if(fieldNo<=0||wireType<0||wireType>5)throw new Error("illegal tag: field no "+fieldNo+" wire type "+wireType);return[fieldNo,wireType]}skip(wireType){let start=this.pos;switch(wireType){case WireType.Varint:while(this.buf[this.pos++]&128){}break;case WireType.Bit64:this.pos+=4;case WireType.Bit32:this.pos+=4;break;case WireType.LengthDelimited:let len=this.uint32();this.pos+=len;break;case WireType.StartGroup:let t;while((t=this.tag()[1])!==WireType.EndGroup){this.skip(t)}break;default:throw new Error("cant skip wire type "+wireType)}this.assertBounds();return this.buf.subarray(start,this.pos)}assertBounds(){if(this.pos>this.len)throw new RangeError("premature EOF")}int32(){return this.uint32()|0}sint32(){let zze=this.uint32();return zze>>>1^-(zze&1)}int64(){return new PbLong(...this.varint64())}uint64(){return new PbULong(...this.varint64())}sint64(){let[lo,hi]=this.varint64();let s=-(lo&1);lo=(lo>>>1|(hi&1)<<31)^s;hi=hi>>>1^s;return new PbLong(lo,hi)}bool(){let[lo,hi]=this.varint64();return lo!==0||hi!==0}fixed32(){return this.view.getUint32((this.pos+=4)-4,true)}sfixed32(){return this.view.getInt32((this.pos+=4)-4,true)}fixed64(){return new PbULong(this.sfixed32(),this.sfixed32())}sfixed64(){return new PbLong(this.sfixed32(),this.sfixed32())}"float"(){return this.view.getFloat32((this.pos+=4)-4,true)}"double"(){return this.view.getFloat64((this.pos+=8)-8,true)}bytes(){let len=this.uint32();let start=this.pos;this.pos+=len;this.assertBounds();return this.buf.subarray(start,start+len)}string(){return this.textDecoder.decode(this.bytes())}}function assert(condition,msg){if(!condition){throw new Error(msg)}}const FLOAT32_MAX=34028234663852886e22,FLOAT32_MIN=-34028234663852886e22,UINT32_MAX=4294967295,INT32_MAX=2147483647,INT32_MIN=-2147483648;function assertInt32(arg){if(typeof arg!=="number")throw new Error("invalid int 32: "+typeof arg);if(!Number.isInteger(arg)||arg>INT32_MAX||arg<INT32_MIN)throw new Error("invalid int 32: "+arg)}function assertUInt32(arg){if(typeof arg!=="number")throw new Error("invalid uint 32: "+typeof arg);if(!Number.isInteger(arg)||arg>UINT32_MAX||arg<0)throw new Error("invalid uint 32: "+arg)}function assertFloat32(arg){if(typeof arg!=="number")throw new Error("invalid float 32: "+typeof arg);if(!Number.isFinite(arg))return;if(arg>FLOAT32_MAX||arg<FLOAT32_MIN)throw new Error("invalid float 32: "+arg)}const defaultsWrite$1={writeUnknownFields:true,writerFactory:()=>new BinaryWriter};function binaryWriteOptions(options){return options?Object.assign(Object.assign({},defaultsWrite$1),options):defaultsWrite$1}class BinaryWriter{constructor(textEncoder){this.stack=[];this.textEncoder=textEncoder!==null&&textEncoder!==void 0?textEncoder:new TextEncoder;this.chunks=[];this.buf=[]}finish(){this.chunks.push(new Uint8Array(this.buf));let len=0;for(let i=0;i<this.chunks.length;i++)len+=this.chunks[i].length;let bytes=new Uint8Array(len);let offset=0;for(let i=0;i<this.chunks.length;i++){bytes.set(this.chunks[i],offset);offset+=this.chunks[i].length}this.chunks=[];return bytes}fork(){this.stack.push({chunks:this.chunks,buf:this.buf});this.chunks=[];this.buf=[];return this}join(){let chunk=this.finish();let prev=this.stack.pop();if(!prev)throw new Error("invalid state, fork stack empty");this.chunks=prev.chunks;this.buf=prev.buf;this.uint32(chunk.byteLength);return this.raw(chunk)}tag(fieldNo,type){return this.uint32((fieldNo<<3|type)>>>0)}raw(chunk){if(this.buf.length){this.chunks.push(new Uint8Array(this.buf));this.buf=[]}this.chunks.push(chunk);return this}uint32(value){assertUInt32(value);while(value>127){this.buf.push(value&127|128);value=value>>>7}this.buf.push(value);return this}int32(value){assertInt32(value);varint32write(value,this.buf);return this}bool(value){this.buf.push(value?1:0);return this}bytes(value){this.uint32(value.byteLength);return this.raw(value)}string(value){let chunk=this.textEncoder.encode(value);this.uint32(chunk.byteLength);return this.raw(chunk)}"float"(value){assertFloat32(value);let chunk=new Uint8Array(4);new DataView(chunk.buffer).setFloat32(0,value,true);return this.raw(chunk)}"double"(value){let chunk=new Uint8Array(8);new DataView(chunk.buffer).setFloat64(0,value,true);return this.raw(chunk)}fixed32(value){assertUInt32(value);let chunk=new Uint8Array(4);new DataView(chunk.buffer).setUint32(0,value,true);return this.raw(chunk)}sfixed32(value){assertInt32(value);let chunk=new Uint8Array(4);new DataView(chunk.buffer).setInt32(0,value,true);return this.raw(chunk)}sint32(value){assertInt32(value);value=(value<<1^value>>31)>>>0;varint32write(value,this.buf);return this}sfixed64(value){let chunk=new Uint8Array(8);let view=new DataView(chunk.buffer);let long=PbLong.from(value);view.setInt32(0,long.lo,true);view.setInt32(4,long.hi,true);return this.raw(chunk)}fixed64(value){let chunk=new Uint8Array(8);let view=new DataView(chunk.buffer);let long=PbULong.from(value);view.setInt32(0,long.lo,true);view.setInt32(4,long.hi,true);return this.raw(chunk)}int64(value){let long=PbLong.from(value);varint64write(long.lo,long.hi,this.buf);return this}sint64(value){let long=PbLong.from(value),sign=long.hi>>31,lo=long.lo<<1^sign,hi=(long.hi<<1|long.lo>>>31)^sign;varint64write(lo,hi,this.buf);return this}uint64(value){let long=PbULong.from(value);varint64write(long.lo,long.hi,this.buf);return this}}const defaultsWrite={emitDefaultValues:false,enumAsInteger:false,useProtoFieldName:false,prettySpaces:0},defaultsRead={ignoreUnknownFields:false};function jsonReadOptions(options){return options?Object.assign(Object.assign({},defaultsRead),options):defaultsRead}function jsonWriteOptions(options){return options?Object.assign(Object.assign({},defaultsWrite),options):defaultsWrite}const MESSAGE_TYPE=Symbol["for"]("protobuf-ts/message-type");function lowerCamelCase(snakeCase){let capNext=false;const sb=[];for(let i=0;i<snakeCase.length;i++){let next=snakeCase.charAt(i);if(next=="_"){capNext=true}else if(/\d/.test(next)){sb.push(next);capNext=true}else if(capNext){sb.push(next.toUpperCase());capNext=false}else if(i==0){sb.push(next.toLowerCase())}else{sb.push(next)}}return sb.join("")}var ScalarType;(function(ScalarType){ScalarType[ScalarType["DOUBLE"]=1]="DOUBLE";ScalarType[ScalarType["FLOAT"]=2]="FLOAT";ScalarType[ScalarType["INT64"]=3]="INT64";ScalarType[ScalarType["UINT64"]=4]="UINT64";ScalarType[ScalarType["INT32"]=5]="INT32";ScalarType[ScalarType["FIXED64"]=6]="FIXED64";ScalarType[ScalarType["FIXED32"]=7]="FIXED32";ScalarType[ScalarType["BOOL"]=8]="BOOL";ScalarType[ScalarType["STRING"]=9]="STRING";ScalarType[ScalarType["BYTES"]=12]="BYTES";ScalarType[ScalarType["UINT32"]=13]="UINT32";ScalarType[ScalarType["SFIXED32"]=15]="SFIXED32";ScalarType[ScalarType["SFIXED64"]=16]="SFIXED64";ScalarType[ScalarType["SINT32"]=17]="SINT32";ScalarType[ScalarType["SINT64"]=18]="SINT64"})(ScalarType||(ScalarType={}));var LongType;(function(LongType){LongType[LongType["BIGINT"]=0]="BIGINT";LongType[LongType["STRING"]=1]="STRING";LongType[LongType["NUMBER"]=2]="NUMBER"})(LongType||(LongType={}));var RepeatType;(function(RepeatType){RepeatType[RepeatType["NO"]=0]="NO";RepeatType[RepeatType["PACKED"]=1]="PACKED";RepeatType[RepeatType["UNPACKED"]=2]="UNPACKED"})(RepeatType||(RepeatType={}));function normalizeFieldInfo(field){var _a,_b,_c,_d;field.localName=(_a=field.localName)!==null&&_a!==void 0?_a:lowerCamelCase(field.name);field.jsonName=(_b=field.jsonName)!==null&&_b!==void 0?_b:lowerCamelCase(field.name);field.repeat=(_c=field.repeat)!==null&&_c!==void 0?_c:RepeatType.NO;field.opt=(_d=field.opt)!==null&&_d!==void 0?_d:field.repeat?false:field.oneof?false:field.kind=="message";return field}function isOneofGroup(any){if(typeof any!="object"||any===null||!any.hasOwnProperty("oneofKind")){return false}switch(typeof any.oneofKind){case"string":if(any[any.oneofKind]===undefined)return false;return Object.keys(any).length==2;case"undefined":return Object.keys(any).length==1;default:return false}}class ReflectionTypeCheck{constructor(info){var _a;this.fields=(_a=info.fields)!==null&&_a!==void 0?_a:[]}prepare(){if(this.data)return;const req=[],known=[],oneofs=[];for(let field of this.fields){if(field.oneof){if(!oneofs.includes(field.oneof)){oneofs.push(field.oneof);req.push(field.oneof);known.push(field.oneof)}}else{known.push(field.localName);switch(field.kind){case"scalar":case"enum":if(!field.opt||field.repeat)req.push(field.localName);break;case"message":if(field.repeat)req.push(field.localName);break;case"map":req.push(field.localName);break}}}this.data={req:req,known:known,oneofs:Object.values(oneofs)}}is(message,depth,allowExcessProperties=false){if(depth<0)return true;if(message===null||message===undefined||typeof message!="object")return false;this.prepare();let keys=Object.keys(message),data=this.data;if(keys.length<data.req.length||data.req.some(n=>!keys.includes(n)))return false;if(!allowExcessProperties){if(keys.some(k=>!data.known.includes(k)))return false}if(depth<1){return true}for(const name of data.oneofs){const group=message[name];if(!isOneofGroup(group))return false;if(group.oneofKind===undefined)continue;const field=this.fields.find(f=>f.localName===group.oneofKind);if(!field)return false;if(!this.field(group[group.oneofKind],field,allowExcessProperties,depth))return false}for(const field of this.fields){if(field.oneof!==undefined)continue;if(!this.field(message[field.localName],field,allowExcessProperties,depth))return false}return true}field(arg,field,allowExcessProperties,depth){let repeated=field.repeat;switch(field.kind){case"scalar":if(arg===undefined)return field.opt;if(repeated)return this.scalars(arg,field.T,depth,field.L);return this.scalar(arg,field.T,field.L);case"enum":if(arg===undefined)return field.opt;if(repeated)return this.scalars(arg,ScalarType.INT32,depth);return this.scalar(arg,ScalarType.INT32);case"message":if(arg===undefined)return true;if(repeated)return this.messages(arg,field.T(),allowExcessProperties,depth);return this.message(arg,field.T(),allowExcessProperties,depth);case"map":if(typeof arg!="object"||arg===null)return false;if(depth<2)return true;if(!this.mapKeys(arg,field.K,depth))return false;switch(field.V.kind){case"scalar":return this.scalars(Object.values(arg),field.V.T,depth,field.V.L);case"enum":return this.scalars(Object.values(arg),ScalarType.INT32,depth);case"message":return this.messages(Object.values(arg),field.V.T(),allowExcessProperties,depth)}break}return true}message(arg,type,allowExcessProperties,depth){if(allowExcessProperties){return type.isAssignable(arg,depth)}return type.is(arg,depth)}messages(arg,type,allowExcessProperties,depth){if(!Array.isArray(arg))return false;if(depth<2)return true;if(allowExcessProperties){for(let i=0;i<arg.length&&i<depth;i++)if(!type.isAssignable(arg[i],depth-1))return false}else{for(let i=0;i<arg.length&&i<depth;i++)if(!type.is(arg[i],depth-1))return false}return true}scalar(arg,type,longType){let argType=typeof arg;switch(type){case ScalarType.UINT64:case ScalarType.FIXED64:case ScalarType.INT64:case ScalarType.SFIXED64:case ScalarType.SINT64:switch(longType){case LongType.BIGINT:return argType=="bigint";case LongType.NUMBER:return argType=="number"&&!isNaN(arg);default:return argType=="string"}case ScalarType.BOOL:return argType=="boolean";case ScalarType.STRING:return argType=="string";case ScalarType.BYTES:return arg instanceof Uint8Array;case ScalarType.DOUBLE:case ScalarType.FLOAT:return argType=="number"&&!isNaN(arg);default:return argType=="number"&&Number.isInteger(arg)}}scalars(arg,type,depth,longType){if(!Array.isArray(arg))return false;if(depth<2)return true;if(Array.isArray(arg))for(let i=0;i<arg.length&&i<depth;i++)if(!this.scalar(arg[i],type,longType))return false;return true}mapKeys(map,type,depth){let keys=Object.keys(map);switch(type){case ScalarType.INT32:case ScalarType.FIXED32:case ScalarType.SFIXED32:case ScalarType.SINT32:case ScalarType.UINT32:return this.scalars(keys.slice(0,depth).map(k=>parseInt(k)),type,depth);case ScalarType.BOOL:return this.scalars(keys.slice(0,depth).map(k=>k=="true"?true:k=="false"?false:k),type,depth);default:return this.scalars(keys,type,depth,LongType.STRING)}}}function reflectionLongConvert(long,type){switch(type){case LongType.BIGINT:return long.toBigInt();case LongType.NUMBER:return long.toNumber();default:return long.toString()}}class ReflectionJsonReader{constructor(info){this.info=info}prepare(){var _a;if(this.fMap===undefined){this.fMap={};const fieldsInput=(_a=this.info.fields)!==null&&_a!==void 0?_a:[];for(const field of fieldsInput){this.fMap[field.name]=field;this.fMap[field.jsonName]=field;this.fMap[field.localName]=field}}}assert(condition,fieldName,jsonValue){if(!condition){let what=typeofJsonValue(jsonValue);if(what=="number"||what=="boolean")what=jsonValue.toString();throw new Error(`Cannot parse JSON ${what} for ${this.info.typeName}#${fieldName}`)}}read(input,message,options){this.prepare();const oneofsHandled=[];for(const[jsonKey,jsonValue]of Object.entries(input)){const field=this.fMap[jsonKey];if(!field){if(!options.ignoreUnknownFields)throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${jsonKey}`);continue}const localName=field.localName;let target;if(field.oneof){if(jsonValue===null&&(field.kind!=="enum"||field.T()[0]!=="google.protobuf.NullValue")){continue}if(oneofsHandled.includes(field.oneof))throw new Error(`Multiple members of the oneof group "${field.oneof}" of ${this.info.typeName} are present in JSON.`);oneofsHandled.push(field.oneof);target=message[field.oneof]={oneofKind:localName}}else{target=message}if(field.kind=="map"){if(jsonValue===null){continue}this.assert(isJsonObject(jsonValue),field.name,jsonValue);const fieldObj=target[localName];for(const[jsonObjKey,jsonObjValue]of Object.entries(jsonValue)){this.assert(jsonObjValue!==null,field.name+" map value",null);let val;switch(field.V.kind){case"message":val=field.V.T().internalJsonRead(jsonObjValue,options);break;case"enum":val=this["enum"](field.V.T(),jsonObjValue,field.name,options.ignoreUnknownFields);if(val===false)continue;break;case"scalar":val=this.scalar(jsonObjValue,field.V.T,field.V.L,field.name);break}this.assert(val!==undefined,field.name+" map value",jsonObjValue);let key=jsonObjKey;if(field.K==ScalarType.BOOL)key=key=="true"?true:key=="false"?false:key;key=this.scalar(key,field.K,LongType.STRING,field.name).toString();fieldObj[key]=val}}else if(field.repeat){if(jsonValue===null)continue;this.assert(Array.isArray(jsonValue),field.name,jsonValue);const fieldArr=target[localName];for(const jsonItem of jsonValue){this.assert(jsonItem!==null,field.name,null);let val;switch(field.kind){case"message":val=field.T().internalJsonRead(jsonItem,options);break;case"enum":val=this["enum"](field.T(),jsonItem,field.name,options.ignoreUnknownFields);if(val===false)continue;break;case"scalar":val=this.scalar(jsonItem,field.T,field.L,field.name);break}this.assert(val!==undefined,field.name,jsonValue);fieldArr.push(val)}}else{switch(field.kind){case"message":if(jsonValue===null&&field.T().typeName!="google.protobuf.Value"){this.assert(field.oneof===undefined,field.name+" (oneof member)",null);continue}target[localName]=field.T().internalJsonRead(jsonValue,options,target[localName]);break;case"enum":let val=this["enum"](field.T(),jsonValue,field.name,options.ignoreUnknownFields);if(val===false)continue;target[localName]=val;break;case"scalar":target[localName]=this.scalar(jsonValue,field.T,field.L,field.name);break}}}}"enum"(type,json,fieldName,ignoreUnknownFields){if(type[0]=="google.protobuf.NullValue")assert(json===null||json==="NULL_VALUE",`Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} only accepts null.`);if(json===null)return 0;switch(typeof json){case"number":assert(Number.isInteger(json),`Unable to parse field ${this.info.typeName}#${fieldName}, enum can only be integral number, got ${json}.`);return json;case"string":let localEnumName=json;if(type[2]&&json.substring(0,type[2].length)===type[2])localEnumName=json.substring(type[2].length);let enumNumber=type[1][localEnumName];if(typeof enumNumber==="undefined"&&ignoreUnknownFields){return false}assert(typeof enumNumber=="number",`Unable to parse field ${this.info.typeName}#${fieldName}, enum ${type[0]} has no value for "${json}".`);return enumNumber}assert(false,`Unable to parse field ${this.info.typeName}#${fieldName}, cannot parse enum value from ${typeof json}".`)}scalar(json,type,longType,fieldName){let e;try{switch(type){case ScalarType.DOUBLE:case ScalarType.FLOAT:if(json===null)return 0;if(json==="NaN")return Number.NaN;if(json==="Infinity")return Number.POSITIVE_INFINITY;if(json==="-Infinity")return Number.NEGATIVE_INFINITY;if(json===""){e="empty string";break}if(typeof json=="string"&&json.trim().length!==json.length){e="extra whitespace";break}if(typeof json!="string"&&typeof json!="number"){break}let float=Number(json);if(Number.isNaN(float)){e="not a number";break}if(!Number.isFinite(float)){e="too large or small";break}if(type==ScalarType.FLOAT)assertFloat32(float);return float;case ScalarType.INT32:case ScalarType.FIXED32:case ScalarType.SFIXED32:case ScalarType.SINT32:case ScalarType.UINT32:if(json===null)return 0;let int32;if(typeof json=="number")int32=json;else if(json==="")e="empty string";else if(typeof json=="string"){if(json.trim().length!==json.length)e="extra whitespace";else int32=Number(json)}if(int32===undefined)break;if(type==ScalarType.UINT32)assertUInt32(int32);else assertInt32(int32);return int32;case ScalarType.INT64:case ScalarType.SFIXED64:case ScalarType.SINT64:if(json===null)return reflectionLongConvert(PbLong.ZERO,longType);if(typeof json!="number"&&typeof json!="string")break;return reflectionLongConvert(PbLong.from(json),longType);case ScalarType.FIXED64:case ScalarType.UINT64:if(json===null)return reflectionLongConvert(PbULong.ZERO,longType);if(typeof json!="number"&&typeof json!="string")break;return reflectionLongConvert(PbULong.from(json),longType);case ScalarType.BOOL:if(json===null)return false;if(typeof json!=="boolean")break;return json;case ScalarType.STRING:if(json===null)return"";if(typeof json!=="string"){e="extra whitespace";break}try{encodeURIComponent(json)}catch(e){e="invalid UTF8";break}return json;case ScalarType.BYTES:if(json===null||json==="")return new Uint8Array(0);if(typeof json!=="string")break;return base64decode(json)}}catch(error){e=error.message}this.assert(false,fieldName+(e?" - "+e:""),json)}}class ReflectionJsonWriter{constructor(info){var _a;this.fields=(_a=info.fields)!==null&&_a!==void 0?_a:[]}write(message,options){const json={},source=message;for(const field of this.fields){if(!field.oneof){let jsonValue=this.field(field,source[field.localName],options);if(jsonValue!==undefined)json[options.useProtoFieldName?field.name:field.jsonName]=jsonValue;continue}const group=source[field.oneof];if(group.oneofKind!==field.localName)continue;const opt=field.kind=="scalar"||field.kind=="enum"?Object.assign(Object.assign({},options),{emitDefaultValues:true}):options;let jsonValue=this.field(field,group[field.localName],opt);assert(jsonValue!==undefined);json[options.useProtoFieldName?field.name:field.jsonName]=jsonValue}return json}field(field,value,options){let jsonValue=undefined;if(field.kind=="map"){assert(typeof value=="object"&&value!==null);const jsonObj={};switch(field.V.kind){case"scalar":for(const[entryKey,entryValue]of Object.entries(value)){const val=this.scalar(field.V.T,entryValue,field.name,false,true);assert(val!==undefined);jsonObj[entryKey.toString()]=val}break;case"message":const messageType=field.V.T();for(const[entryKey,entryValue]of Object.entries(value)){const val=this.message(messageType,entryValue,field.name,options);assert(val!==undefined);jsonObj[entryKey.toString()]=val}break;case"enum":const enumInfo=field.V.T();for(const[entryKey,entryValue]of Object.entries(value)){assert(entryValue===undefined||typeof entryValue=="number");const val=this["enum"](enumInfo,entryValue,field.name,false,true,options.enumAsInteger);assert(val!==undefined);jsonObj[entryKey.toString()]=val}break}if(options.emitDefaultValues||Object.keys(jsonObj).length>0)jsonValue=jsonObj}else if(field.repeat){assert(Array.isArray(value));const jsonArr=[];switch(field.kind){case"scalar":for(let i=0;i<value.length;i++){const val=this.scalar(field.T,value[i],field.name,field.opt,true);assert(val!==undefined);jsonArr.push(val)}break;case"enum":const enumInfo=field.T();for(let i=0;i<value.length;i++){assert(value[i]===undefined||typeof value[i]=="number");const val=this["enum"](enumInfo,value[i],field.name,field.opt,true,options.enumAsInteger);assert(val!==undefined);jsonArr.push(val)}break;case"message":const messageType=field.T();for(let i=0;i<value.length;i++){const val=this.message(messageType,value[i],field.name,options);assert(val!==undefined);jsonArr.push(val)}break}if(options.emitDefaultValues||jsonArr.length>0||options.emitDefaultValues)jsonValue=jsonArr}else{switch(field.kind){case"scalar":jsonValue=this.scalar(field.T,value,field.name,field.opt,options.emitDefaultValues);break;case"enum":jsonValue=this["enum"](field.T(),value,field.name,field.opt,options.emitDefaultValues,options.enumAsInteger);break;case"message":jsonValue=this.message(field.T(),value,field.name,options);break}}return jsonValue}"enum"(type,value,fieldName,optional,emitDefaultValues,enumAsInteger){if(type[0]=="google.protobuf.NullValue")return!emitDefaultValues&&!optional?undefined:null;if(value===undefined){assert(optional);return undefined}if(value===0&&!emitDefaultValues&&!optional)return undefined;assert(typeof value=="number");assert(Number.isInteger(value));if(enumAsInteger||!type[1].hasOwnProperty(value))return value;if(type[2])return type[2]+type[1][value];return type[1][value]}message(type,value,fieldName,options){if(value===undefined)return options.emitDefaultValues?null:undefined;return type.internalJsonWrite(value,options)}scalar(type,value,fieldName,optional,emitDefaultValues){if(value===undefined){assert(optional);return undefined}const ed=emitDefaultValues||optional;switch(type){case ScalarType.INT32:case ScalarType.SFIXED32:case ScalarType.SINT32:if(value===0)return ed?0:undefined;assertInt32(value);return value;case ScalarType.FIXED32:case ScalarType.UINT32:if(value===0)return ed?0:undefined;assertUInt32(value);return value;case ScalarType.FLOAT:assertFloat32(value);case ScalarType.DOUBLE:if(value===0)return ed?0:undefined;assert(typeof value=="number");if(Number.isNaN(value))return"NaN";if(value===Number.POSITIVE_INFINITY)return"Infinity";if(value===Number.NEGATIVE_INFINITY)return"-Infinity";return value;case ScalarType.STRING:if(value==="")return ed?"":undefined;assert(typeof value=="string");return value;case ScalarType.BOOL:if(value===false)return ed?false:undefined;assert(typeof value=="boolean");return value;case ScalarType.UINT64:case ScalarType.FIXED64:assert(typeof value=="number"||typeof value=="string"||typeof value=="bigint");let ulong=PbULong.from(value);if(ulong.isZero()&&!ed)return undefined;return ulong.toString();case ScalarType.INT64:case ScalarType.SFIXED64:case ScalarType.SINT64:assert(typeof value=="number"||typeof value=="string"||typeof value=="bigint");let long=PbLong.from(value);if(long.isZero()&&!ed)return undefined;return long.toString();case ScalarType.BYTES:assert(value instanceof Uint8Array);if(!value.byteLength)return ed?"":undefined;return base64encode(value)}}}function reflectionScalarDefault(type,longType=LongType.STRING){switch(type){case ScalarType.BOOL:return false;case ScalarType.UINT64:case ScalarType.FIXED64:return reflectionLongConvert(PbULong.ZERO,longType);case ScalarType.INT64:case ScalarType.SFIXED64:case ScalarType.SINT64:return reflectionLongConvert(PbLong.ZERO,longType);case ScalarType.DOUBLE:case ScalarType.FLOAT:return 0;case ScalarType.BYTES:return new Uint8Array(0);case ScalarType.STRING:return"";default:return 0}}class ReflectionBinaryReader{constructor(info){this.info=info}prepare(){var _a;if(!this.fieldNoToField){const fieldsInput=(_a=this.info.fields)!==null&&_a!==void 0?_a:[];this.fieldNoToField=new Map(fieldsInput.map(field=>[field.no,field]))}}read(reader,message,options,length){this.prepare();const end=length===undefined?reader.len:reader.pos+length;while(reader.pos<end){const[fieldNo,wireType]=reader.tag(),field=this.fieldNoToField.get(fieldNo);if(!field){let u=options.readUnknownField;if(u=="throw")throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.info.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.info.typeName,message,fieldNo,wireType,d);continue}let target=message,repeated=field.repeat,localName=field.localName;if(field.oneof){target=target[field.oneof];if(target.oneofKind!==localName)target=message[field.oneof]={oneofKind:localName}}switch(field.kind){case"scalar":case"enum":let T=field.kind=="enum"?ScalarType.INT32:field.T;let L=field.kind=="scalar"?field.L:undefined;if(repeated){let arr=target[localName];if(wireType==WireType.LengthDelimited&&T!=ScalarType.STRING&&T!=ScalarType.BYTES){let e=reader.uint32()+reader.pos;while(reader.pos<e)arr.push(this.scalar(reader,T,L))}else arr.push(this.scalar(reader,T,L))}else target[localName]=this.scalar(reader,T,L);break;case"message":if(repeated){let arr=target[localName];let msg=field.T().internalBinaryRead(reader,reader.uint32(),options);arr.push(msg)}else target[localName]=field.T().internalBinaryRead(reader,reader.uint32(),options,target[localName]);break;case"map":let[mapKey,mapVal]=this.mapEntry(field,reader,options);target[localName][mapKey]=mapVal;break}}}mapEntry(field,reader,options){let length=reader.uint32();let end=reader.pos+length;let key=undefined;let val=undefined;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:if(field.K==ScalarType.BOOL)key=reader.bool().toString();else key=this.scalar(reader,field.K,LongType.STRING);break;case 2:switch(field.V.kind){case"scalar":val=this.scalar(reader,field.V.T,field.V.L);break;case"enum":val=reader.int32();break;case"message":val=field.V.T().internalBinaryRead(reader,reader.uint32(),options);break}break;default:throw new Error(`Unknown field ${fieldNo} (wire type ${wireType}) in map entry for ${this.info.typeName}#${field.name}`)}}if(key===undefined){let keyRaw=reflectionScalarDefault(field.K);key=field.K==ScalarType.BOOL?keyRaw.toString():keyRaw}if(val===undefined)switch(field.V.kind){case"scalar":val=reflectionScalarDefault(field.V.T,field.V.L);break;case"enum":val=0;break;case"message":val=field.V.T().create();break}return[key,val]}scalar(reader,type,longType){switch(type){case ScalarType.INT32:return reader.int32();case ScalarType.STRING:return reader.string();case ScalarType.BOOL:return reader.bool();case ScalarType.DOUBLE:return reader["double"]();case ScalarType.FLOAT:return reader["float"]();case ScalarType.INT64:return reflectionLongConvert(reader.int64(),longType);case ScalarType.UINT64:return reflectionLongConvert(reader.uint64(),longType);case ScalarType.FIXED64:return reflectionLongConvert(reader.fixed64(),longType);case ScalarType.FIXED32:return reader.fixed32();case ScalarType.BYTES:return reader.bytes();case ScalarType.UINT32:return reader.uint32();case ScalarType.SFIXED32:return reader.sfixed32();case ScalarType.SFIXED64:return reflectionLongConvert(reader.sfixed64(),longType);case ScalarType.SINT32:return reader.sint32();case ScalarType.SINT64:return reflectionLongConvert(reader.sint64(),longType)}}}class ReflectionBinaryWriter{constructor(info){this.info=info}prepare(){if(!this.fields){const fieldsInput=this.info.fields?this.info.fields.concat():[];this.fields=fieldsInput.sort((a,b)=>a.no-b.no)}}write(message,writer,options){this.prepare();for(const field of this.fields){let value,emitDefault,repeated=field.repeat,localName=field.localName;if(field.oneof){const group=message[field.oneof];if(group.oneofKind!==localName)continue;value=group[localName];emitDefault=true}else{value=message[localName];emitDefault=false}switch(field.kind){case"scalar":case"enum":let T=field.kind=="enum"?ScalarType.INT32:field.T;if(repeated){assert(Array.isArray(value));if(repeated==RepeatType.PACKED)this.packed(writer,T,field.no,value);else for(const item of value)this.scalar(writer,T,field.no,item,true)}else if(value===undefined)assert(field.opt);else this.scalar(writer,T,field.no,value,emitDefault||field.opt);break;case"message":if(repeated){assert(Array.isArray(value));for(const item of value)this.message(writer,options,field.T(),field.no,item)}else{this.message(writer,options,field.T(),field.no,value)}break;case"map":assert(typeof value=="object"&&value!==null);for(const[key,val]of Object.entries(value))this.mapEntry(writer,options,field,key,val);break}}let u=options.writeUnknownFields;if(u!==false)(u===true?UnknownFieldHandler.onWrite:u)(this.info.typeName,message,writer)}mapEntry(writer,options,field,key,value){writer.tag(field.no,WireType.LengthDelimited);writer.fork();let keyValue=key;switch(field.K){case ScalarType.INT32:case ScalarType.FIXED32:case ScalarType.UINT32:case ScalarType.SFIXED32:case ScalarType.SINT32:keyValue=Number.parseInt(key);break;case ScalarType.BOOL:assert(key=="true"||key=="false");keyValue=key=="true";break}this.scalar(writer,field.K,1,keyValue,true);switch(field.V.kind){case"scalar":this.scalar(writer,field.V.T,2,value,true);break;case"enum":this.scalar(writer,ScalarType.INT32,2,value,true);break;case"message":this.message(writer,options,field.V.T(),2,value);break}writer.join()}message(writer,options,handler,fieldNo,value){if(value===undefined)return;handler.internalBinaryWrite(value,writer.tag(fieldNo,WireType.LengthDelimited).fork(),options);writer.join()}scalar(writer,type,fieldNo,value,emitDefault){let[wireType,method,isDefault]=this.scalarInfo(type,value);if(!isDefault||emitDefault){writer.tag(fieldNo,wireType);writer[method](value)}}packed(writer,type,fieldNo,value){if(!value.length)return;assert(type!==ScalarType.BYTES&&type!==ScalarType.STRING);writer.tag(fieldNo,WireType.LengthDelimited);writer.fork();let[,method]=this.scalarInfo(type);for(let i=0;i<value.length;i++)writer[method](value[i]);writer.join()}scalarInfo(type,value){let t=WireType.Varint;let m;let i=value===undefined;let d=value===0;switch(type){case ScalarType.INT32:m="int32";break;case ScalarType.STRING:d=i||!value.length;t=WireType.LengthDelimited;m="string";break;case ScalarType.BOOL:d=value===false;m="bool";break;case ScalarType.UINT32:m="uint32";break;case ScalarType.DOUBLE:t=WireType.Bit64;m="double";break;case ScalarType.FLOAT:t=WireType.Bit32;m="float";break;case ScalarType.INT64:d=i||PbLong.from(value).isZero();m="int64";break;case ScalarType.UINT64:d=i||PbULong.from(value).isZero();m="uint64";break;case ScalarType.FIXED64:d=i||PbULong.from(value).isZero();t=WireType.Bit64;m="fixed64";break;case ScalarType.BYTES:d=i||!value.byteLength;t=WireType.LengthDelimited;m="bytes";break;case ScalarType.FIXED32:t=WireType.Bit32;m="fixed32";break;case ScalarType.SFIXED32:t=WireType.Bit32;m="sfixed32";break;case ScalarType.SFIXED64:d=i||PbLong.from(value).isZero();t=WireType.Bit64;m="sfixed64";break;case ScalarType.SINT32:m="sint32";break;case ScalarType.SINT64:d=i||PbLong.from(value).isZero();m="sint64";break}return[t,m,i||d]}}function reflectionCreate(type){const msg=type.messagePrototype?Object.create(type.messagePrototype):Object.defineProperty({},MESSAGE_TYPE,{value:type});for(let field of type.fields){let name=field.localName;if(field.opt)continue;if(field.oneof)msg[field.oneof]={oneofKind:undefined};else if(field.repeat)msg[name]=[];else switch(field.kind){case"scalar":msg[name]=reflectionScalarDefault(field.T,field.L);break;case"enum":msg[name]=0;break;case"map":msg[name]={};break}}return msg}function reflectionMergePartial(info,target,source){let fieldValue,input=source,output;for(let field of info.fields){let name=field.localName;if(field.oneof){const group=input[field.oneof];if((group===null||group===void 0?void 0:group.oneofKind)==undefined){continue}fieldValue=group[name];output=target[field.oneof];output.oneofKind=group.oneofKind;if(fieldValue==undefined){delete output[name];continue}}else{fieldValue=input[name];output=target;if(fieldValue==undefined){continue}}if(field.repeat)output[name].length=fieldValue.length;switch(field.kind){case"scalar":case"enum":if(field.repeat)for(let i=0;i<fieldValue.length;i++)output[name][i]=fieldValue[i];else output[name]=fieldValue;break;case"message":let T=field.T();if(field.repeat)for(let i=0;i<fieldValue.length;i++)output[name][i]=T.create(fieldValue[i]);else if(output[name]===undefined)output[name]=T.create(fieldValue);else T.mergePartial(output[name],fieldValue);break;case"map":switch(field.V.kind){case"scalar":case"enum":Object.assign(output[name],fieldValue);break;case"message":let T=field.V.T();for(let k of Object.keys(fieldValue))output[name][k]=T.create(fieldValue[k]);break}break}}}function reflectionEquals(info,a,b){if(a===b)return true;if(!a||!b)return false;for(let field of info.fields){let localName=field.localName;let val_a=field.oneof?a[field.oneof][localName]:a[localName];let val_b=field.oneof?b[field.oneof][localName]:b[localName];switch(field.kind){case"enum":case"scalar":let t=field.kind=="enum"?ScalarType.INT32:field.T;if(!(field.repeat?repeatedPrimitiveEq(t,val_a,val_b):primitiveEq(t,val_a,val_b)))return false;break;case"map":if(!(field.V.kind=="message"?repeatedMsgEq(field.V.T(),objectValues(val_a),objectValues(val_b)):repeatedPrimitiveEq(field.V.kind=="enum"?ScalarType.INT32:field.V.T,objectValues(val_a),objectValues(val_b))))return false;break;case"message":let T=field.T();if(!(field.repeat?repeatedMsgEq(T,val_a,val_b):T.equals(val_a,val_b)))return false;break}}return true}const objectValues=Object.values;function primitiveEq(type,a,b){if(a===b)return true;if(type!==ScalarType.BYTES)return false;let ba=a;let bb=b;if(ba.length!==bb.length)return false;for(let i=0;i<ba.length;i++)if(ba[i]!=bb[i])return false;return true}function repeatedPrimitiveEq(type,a,b){if(a.length!==b.length)return false;for(let i=0;i<a.length;i++)if(!primitiveEq(type,a[i],b[i]))return false;return true}function repeatedMsgEq(type,a,b){if(a.length!==b.length)return false;for(let i=0;i<a.length;i++)if(!type.equals(a[i],b[i]))return false;return true}const baseDescriptors=Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));class MessageType{constructor(name,fields,options){this.defaultCheckDepth=16;this.typeName=name;this.fields=fields.map(normalizeFieldInfo);this.options=options!==null&&options!==void 0?options:{};this.messagePrototype=Object.create(null,Object.assign(Object.assign({},baseDescriptors),{[MESSAGE_TYPE]:{value:this}}));this.refTypeCheck=new ReflectionTypeCheck(this);this.refJsonReader=new ReflectionJsonReader(this);this.refJsonWriter=new ReflectionJsonWriter(this);this.refBinReader=new ReflectionBinaryReader(this);this.refBinWriter=new ReflectionBinaryWriter(this)}create(value){let message=reflectionCreate(this);if(value!==undefined){reflectionMergePartial(this,message,value)}return message}clone(message){let copy=this.create();reflectionMergePartial(this,copy,message);return copy}equals(a,b){return reflectionEquals(this,a,b)}is(arg,depth=this.defaultCheckDepth){return this.refTypeCheck.is(arg,depth,false)}isAssignable(arg,depth=this.defaultCheckDepth){return this.refTypeCheck.is(arg,depth,true)}mergePartial(target,source){reflectionMergePartial(this,target,source)}fromBinary(data,options){let opt=binaryReadOptions(options);return this.internalBinaryRead(opt.readerFactory(data),data.byteLength,opt)}fromJson(json,options){return this.internalJsonRead(json,jsonReadOptions(options))}fromJsonString(json,options){let value=JSON.parse(json);return this.fromJson(value,options)}toJson(message,options){return this.internalJsonWrite(message,jsonWriteOptions(options))}toJsonString(message,options){var _a;let value=this.toJson(message,options);return JSON.stringify(value,null,(_a=options===null||options===void 0?void 0:options.prettySpaces)!==null&&_a!==void 0?_a:0)}toBinary(message,options){let opt=binaryWriteOptions(options);return this.internalBinaryWrite(message,opt.writerFactory(),opt).finish()}internalJsonRead(json,options,target){if(json!==null&&typeof json=="object"&&!Array.isArray(json)){let message=target!==null&&target!==void 0?target:this.create();this.refJsonReader.read(json,message,options);return message}throw new Error(`Unable to parse message ${this.typeName} from JSON ${typeofJsonValue(json)}.`)}internalJsonWrite(message,options){return this.refJsonWriter.write(message,options)}internalBinaryWrite(message,writer,options){this.refBinWriter.write(message,writer,options);return writer}internalBinaryRead(reader,length,options,target){let message=target!==null&&target!==void 0?target:this.create();this.refBinReader.read(reader,message,options,length);return message}}const $=new ENV("📺 BiliBili: 🛡️ ADBlock v0.6.3(1007) response.beta");const url=new URL($request.url);$.log(`⚠ url: ${url.toJSON()}`,"");const METHOD=$request.method,HOST=url.hostname,PATH=url.pathname,PATHs=url.pathname.split("/").filter(Boolean);$.log(`⚠ METHOD: ${METHOD}, HOST: ${HOST}, PATH: ${PATH}`,"");const FORMAT=($response.headers?.["Content-Type"]??$response.headers?.["content-type"])?.split(";")?.[0];$.log(`⚠ FORMAT: ${FORMAT}`,"");!(async()=>{const{Settings,Caches,Configs}=setENV("BiliBili","ADBlock",Database$1);$.log(`⚠ Settings.Switch: ${Settings?.Switch}`,"");switch(Settings.Switch){case true:default:let body={code:0,message:"0",data:{}};switch(FORMAT){case undefined:break;case"application/x-www-form-urlencoded":case"text/plain":default:break;case"application/x-mpegURL":case"application/x-mpegurl":case"application/vnd.apple.mpegurl":case"audio/mpegurl":break;case"text/xml":case"text/html":case"text/plist":case"application/xml":case"application/plist":case"application/x-plist":break;case"text/vtt":case"application/vtt":break;case"text/json":case"application/json":body=JSON.parse($response.body??"{}");switch(HOST){case"www.bilibili.com":break;case"app.bilibili.com":case"app.biliapi.net":switch(PATH){case"/x/v2/splash/show":case"/x/v2/splash/list":case"/x/v2/splash/brand/list":case"/x/v2/splash/event/list2":switch(Settings?.Detail?.splash){case true:default:$.log(`🎉 开屏页广告去除`);const item=["account","event_list","preload","show"];if(body.data){item.forEach(i=>{delete body.data[i]})}break;case false:$.log(`🚧 用户设置开屏页广告不去除`);break}break;case"/x/v2/feed/index":switch(Settings?.Detail?.feed){case true:default:if(body.data.items?.length){body.data.items=await Promise.all(body.data.items.map(async item=>{const{card_type:cardType,card_goto:cardGoto,"goto":Goto}=item;if(cardType&&cardGoto){if(["banner_v8","banner_ipad_v8"].includes(cardType)&&cardGoto==="banner"){switch(Settings?.Detail?.activity){case true:default:Caches.banner_hash=item.hash;$Storage.setItem("@BiliBili.ADBlock.Caches",Caches);$.log(`🎉 推荐页活动大图去除`);return undefined;case false:if(item.banner_item){item.banner_item=item.banner_item.filter(i=>{if(i.type==="ad"){$.log(`🎉 推荐页大图广告去除`);return false}return true})}break}}else if(["cm_v2","cm_v1"].includes(cardType)&&["ad_web_s","ad_av","ad_web_gif"].includes(cardGoto)){$.log(`🎉 ${cardGoto}广告去除`);if(url.searchParams.get("device")!=="phone"){return undefined}else{await fixPosition().then(result=>item=result)}}else if(cardGoto==="live"&&cardType==="small_cover_v9"){$.log("🎉移除直播");if(url.searchParams.get("device")!=="phone"){return undefined}else{await fixPosition().then(result=>item=result)}}else if(cardType==="cm_v2"&&["ad_player","ad_inline_3d","ad_inline_eggs","ad_inline_live"].includes(cardGoto)){$.log(`🎉 ${cardGoto}广告去除`);return undefined}else if(cardType==="small_cover_v10"&&cardGoto==="game"){$.log(`🎉 游戏广告去除`);if(url.searchParams.get("device")!=="phone"){return undefined}else{await fixPosition().then(result=>item=result)}}else if(cardType==="cm_double_v9"&&cardGoto==="ad_inline_av"){$.log(`🎉 大视频广告去除`);return undefined}else if(Goto==="vertical_av"){switch(Settings?.Detail?.vertical){case true:default:$.log(`🎉 竖屏视频去除`);await fixPosition().then(result=>item=result);break;case false:$.log(`🚧 用户设置推荐页竖屏视频不去除`);break}}}return item}));body.data.items=body.data.items.filter(fix=>fix!==undefined)}async function fixPosition(){let itemsCache=$Storage.getItem("@BiliBili.Index.Caches","");let singleItem={};if(itemsCache&&itemsCache.length>0){singleItem=itemsCache.pop();$.log(`🎉 推荐页空缺位填充成功`)}else{const myRequest={url:$request.url,headers:$request.heders};await $.fetch(myRequest).then(response=>{try{const body=JSON.parse(response.body||"{}");if(body?.code===0&&body?.message==="0"){body.data.items=body.data.items.map(item=>{const{card_type:cardType,card_goto:cardGoto,"goto":Goto}=item;if(cardType&&cardGoto){if(cardType==="banner_v8"&&cardGoto==="banner"){return undefined}else if(cardType==="cm_v2"&&["ad_web_s","ad_av","ad_web_gif","ad_player","ad_inline_3d","ad_inline_eggs","ad_inline_live"].includes(cardGoto)){return undefined}else if(cardType==="small_cover_v10"&&cardGoto==="game"){return undefined}else if(cardType==="cm_double_v9"&&cardGoto==="ad_inline_av"){return undefined}else if(cardType==="large_cover_v9"&&cardGoto==="inline_av_v2"){return undefined}else if(Goto==="vertical_av"){return undefined}}return item}).filter(fix=>fix!==undefined);$Storage.setItem("@BiliBili.Index.Caches",body.data.items);$.log(`🎉 推荐页缓存数组补充成功`)}else{$.log(`🚧 访问推荐页尝试填补失败`)}}catch(e){$.logErr(e,response)}});itemsCache=$Storage.getItem("@BiliBili.Index.Caches","");if(itemsCache.length>0){singleItem=itemsCache.pop();$.log(`🎉 推荐页空缺位填充成功`)}}$Storage.setItem("@BiliBili.Index.Caches",itemsCache);return singleItem}break;case false:$.log(`🚧 用户设置推荐页广告不去除`);break}break;case"/x/v2/feed/index/story":switch(Settings?.Detail?.story){case true:default:if(body.data?.items){$.log(`🎉 首页短视频流广告去除`);body.data.items=body.data.items.filter(i=>!(i.hasOwnProperty("ad_info")||["vertical_ad_av","vertical_pgc"].includes(i.card_goto)))}break;case false:$.log(`🚧 用户设置首页短视频流广告不去除`);break}break;case"/x/v2/search/square":switch(Settings?.Detail?.Hot_search){case true:default:$.log(`🎉 搜索页热搜内容去除`);body.data=body.data.filter(i=>!(i.type==="trending"));break;case false:$.log(`🚧 用户设置搜索页热搜内容不去除`);break}break}break;case"api.bilibili.com":case"api.biliapi.net":switch(PATH){case"/pgc/page/bangumi":case"/pgc/page/cinema/tab":switch(Settings?.Detail?.cinema){case true:default:if(body.result?.modules){$.log(`🎉 观影页广告去除`);body.result.modules.forEach(i=>{if(i.style.startsWith("banner")){i.items=i.items.filter(j=>j.link.includes("play"))}else if(i.style.startsWith("function")){i.items=i.items.filter(j=>j.blink.startsWith("bilibili"))}else if([241,1283,1284,1441].includes(i.module_id)){i.items=[]}else if(i.style.startsWith("tip")){i.items=[]}})}break;case false:$.log(`🚧 用户设置观影页广告不去除`);break}break;case"/x/player/wbi/playurl":break;case"/x/web-interface/wbi/index/top/feed/rcmd":switch(Settings?.Detail?.feed){case true:default:$.log(`🎉 首页广告内容去除`);body.data.item=body.data.item.filter(i=>!(i["goto"]==="ad"));break;case false:$.log(`🚧 用户设置首页广告不去除`);break}break}break;case"api.live.bilibili.com":switch(PATH){case"/xlive/app-room/v1/index/getInfoByRoom":switch(Settings?.Detail?.xlive){case true:default:$.log(`🎉 直播banner广告去除`);delete body.data?.activity_banner_info;if(body.data?.shopping_info){body.data.shopping_info={is_show:0};$.log(`🎉 直播购物广告去除`)}if(body.data?.new_tab_info?.outer_list?.length>0){body.data.new_tab_info.outer_list=body.data.new_tab_info.outer_list.filter(i=>i.biz_id!==33)}break;case false:$.log(`🚧 用户设置直播页广告不去除`);break}break}break}$response.body=JSON.stringify(body);break;case"application/protobuf":case"application/x-protobuf":case"application/vnd.google.protobuf":case"application/grpc":case"application/grpc+proto":case"applecation/octet-stream":let rawBody=$.isQuanX()?new Uint8Array($response.bodyBytes??[]):$response.body??new Uint8Array;switch(FORMAT){case"application/protobuf":case"application/x-protobuf":case"application/vnd.google.protobuf":break;case"application/grpc":case"application/grpc+proto":let header=rawBody.slice(0,5);body=rawBody.slice(5);switch(header?.[0]){case 0:break;case 1:body=pako$1.ungzip(body);header[0]=0;break}switch(HOST){case"grpc.biliapi.net":case"app.bilibili.com":class Any$Type extends MessageType{constructor(){super("google.protobuf.Any",[{no:1,name:"type_url",kind:"scalar",T:9},{no:2,name:"value",kind:"scalar",T:12}])}pack(message,type){return{typeUrl:this.typeNameToUrl(type.typeName),value:type.toBinary(message)}}unpack(any,type,options){if(!this.contains(any,type))throw new Error("Cannot unpack google.protobuf.Any with typeUrl '"+any.typeUrl+"' as "+type.typeName+".");return type.fromBinary(any.value,options)}contains(any,type){if(!any.typeUrl.length)return false;let wants=typeof type=="string"?type:type.typeName;let has=this.typeUrlToName(any.typeUrl);return wants===has}internalJsonWrite(any,options){if(any.typeUrl==="")return{};let typeName=this.typeUrlToName(any.typeUrl);let opt=jsonWriteOptions(options);let type=opt.typeRegistry?.find(t=>t.typeName===typeName);if(!type)throw new globalThis.Error("Unable to convert google.protobuf.Any with typeUrl '"+any.typeUrl+"' to JSON. The specified type "+typeName+" is not available in the type registry.");let value=type.fromBinary(any.value,{readUnknownField:false});let json=type.internalJsonWrite(value,opt);if(typeName.startsWith("google.protobuf.")||!isJsonObject(json))json={value:json};json["@type"]=any.typeUrl;return json}internalJsonRead(json,options,target){if(!isJsonObject(json))throw new globalThis.Error("Unable to parse google.protobuf.Any from JSON "+typeofJsonValue(json)+".");if(typeof json["@type"]!="string"||json["@type"]=="")return this.create();let typeName=this.typeUrlToName(json["@type"]);let type=options?.typeRegistry?.find(t=>t.typeName==typeName);if(!type)throw new globalThis.Error("Unable to parse google.protobuf.Any from JSON. The specified type "+typeName+" is not available in the type registry.");let value;if(typeName.startsWith("google.protobuf.")&&json.hasOwnProperty("value"))value=type.fromJson(json["value"],options);else{let copy=Object.assign({},json);delete copy["@type"];value=type.fromJson(copy,options)}if(target===undefined)target=this.create();target.typeUrl=json["@type"];target.value=type.toBinary(value);return target}typeNameToUrl(name){if(!name.length)throw new Error("invalid type name: "+name);return"type.googleapis.com/"+name}typeUrlToName(url){if(!url.length)throw new Error("invalid type url: "+url);let slash=url.lastIndexOf("/");let name=slash>0?url.substring(slash+1):url;if(!name.length)throw new Error("invalid type url: "+url);return name}create(value){const message={typeUrl:"",value:new Uint8Array(0)};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.typeUrl=reader.string();break;case 2:message.value=reader.bytes();break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.typeUrl!=="")writer.tag(1,WireType.LengthDelimited).string(message.typeUrl);if(message.value.length)writer.tag(2,WireType.LengthDelimited).bytes(message.value);let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const Any=new Any$Type;class CM$Type extends MessageType{constructor(){super("CM",[{no:1,name:"source_content",kind:"message",T:()=>Any}])}create(value){const message={};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.sourceContent=Any.internalBinaryRead(reader,reader.uint32(),options,message.sourceContent);break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.sourceContent)Any.internalBinaryWrite(message.sourceContent,writer.tag(1,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const CM=new CM$Type;switch(PATHs?.[0]){case"bilibili.app.playurl.v1.PlayURL":switch(PATHs?.[1]){case"PlayView":class PlayViewReply$Type extends MessageType{constructor(){super("PlayViewReply",[{no:5,name:"play_arc",kind:"message",T:()=>PlayArcConf}])}create(value){const message={};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 5:message.playArc=PlayArcConf.internalBinaryRead(reader,reader.uint32(),options,message.playArc);break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.playArc)PlayArcConf.internalBinaryWrite(message.playArc,writer.tag(5,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const PlayViewReply=new PlayViewReply$Type;class PlayArcConf$Type extends MessageType{constructor(){super("PlayArcConf",[{no:1,name:"background_play_conf",kind:"message",T:()=>ArcConf}])}create(value){const message={};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.backgroundPlayConf=ArcConf.internalBinaryRead(reader,reader.uint32(),options,message.backgroundPlayConf);break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.backgroundPlayConf)ArcConf.internalBinaryWrite(message.backgroundPlayConf,writer.tag(1,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const PlayArcConf=new PlayArcConf$Type;class ArcConf$Type extends MessageType{constructor(){super("ArcConf",[{no:1,name:"is_support",kind:"scalar",T:8},{no:2,name:"disabled",kind:"scalar",T:8},{no:3,name:"extra_content",kind:"message",T:()=>ExtraContent}])}create(value){const message={isSupport:false,disabled:false};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.isSupport=reader.bool();break;case 2:message.disabled=reader.bool();break;case 3:message.extraContent=ExtraContent.internalBinaryRead(reader,reader.uint32(),options,message.extraContent);break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.isSupport!==false)writer.tag(1,WireType.Varint).bool(message.isSupport);if(message.disabled!==false)writer.tag(2,WireType.Varint).bool(message.disabled);if(message.extraContent)ExtraContent.internalBinaryWrite(message.extraContent,writer.tag(3,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const ArcConf=new ArcConf$Type;class ExtraContent$Type extends MessageType{constructor(){super("ExtraContent",[{no:1,name:"disabled_reason",kind:"scalar",T:9},{no:2,name:"disabled_code",kind:"scalar",T:3,L:0}])}create(value){const message={disabledReason:"",disabledCode:0n};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.disabledReason=reader.string();break;case 2:message.disabledCode=reader.int64().toBigInt();break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.disabledReason!=="")writer.tag(1,WireType.LengthDelimited).string(message.disabledReason);if(message.disabledCode!==0n)writer.tag(2,WireType.Varint).int64(message.disabledCode);let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const ExtraContent=new ExtraContent$Type;let data=PlayViewReply.fromBinary(body);const oldBackgroundConf=data.playArc?.backgroundPlayConf;if(oldBackgroundConf&&(!oldBackgroundConf.isSupport||oldBackgroundConf.disabled)){$.log(`🎉 后台播放限制去除`);data.playArc.backgroundPlayConf.isSupport=true;data.playArc.backgroundPlayConf.disabled=false;data.playArc.backgroundPlayConf.extraContent=null}else{$.log(`🚧 无后台播放限制`)}body=PlayViewReply.toBinary(data);break}break;case"bilibili.app.dynamic.v2.Dynamic":var DynamicType;(function(DynamicType){DynamicType[DynamicType["dyn_none"]=0]="dyn_none";DynamicType[DynamicType["ad"]=15]="ad"})(DynamicType||(DynamicType={}));class DynAllReply$Type extends MessageType{constructor(){super("DynAllReply",[{no:1,name:"dynamic_list",kind:"message",T:()=>DynamicList},{no:2,name:"up_list",kind:"message",T:()=>CardVideoUpList},{no:3,name:"topic_list",kind:"message",T:()=>TopicList}])}create(value){const message={};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.dynamicList=DynamicList.internalBinaryRead(reader,reader.uint32(),options,message.dynamicList);break;case 2:message.upList=CardVideoUpList.internalBinaryRead(reader,reader.uint32(),options,message.upList);break;case 3:message.topicList=TopicList.internalBinaryRead(reader,reader.uint32(),options,message.topicList);break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.dynamicList)DynamicList.internalBinaryWrite(message.dynamicList,writer.tag(1,WireType.LengthDelimited).fork(),options).join();if(message.upList)CardVideoUpList.internalBinaryWrite(message.upList,writer.tag(2,WireType.LengthDelimited).fork(),options).join();if(message.topicList)TopicList.internalBinaryWrite(message.topicList,writer.tag(3,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const DynAllReply=new DynAllReply$Type;class DynVideoReply$Type extends MessageType{constructor(){super("DynVideoReply",[{no:2,name:"video_up_list",kind:"message",T:()=>CardVideoUpList}])}create(value){const message={};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 2:message.videoUpList=CardVideoUpList.internalBinaryRead(reader,reader.uint32(),options,message.videoUpList);break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.videoUpList)CardVideoUpList.internalBinaryWrite(message.videoUpList,writer.tag(2,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const DynVideoReply=new DynVideoReply$Type;class DynamicList$Type extends MessageType{constructor(){super("DynamicList",[{no:1,name:"list",kind:"message",repeat:1,T:()=>DynamicItem}])}create(value){const message={list:[]};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.list.push(DynamicItem.internalBinaryRead(reader,reader.uint32(),options));break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){for(let i=0;i<message.list.length;i++)DynamicItem.internalBinaryWrite(message.list[i],writer.tag(1,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const DynamicList=new DynamicList$Type;class CardVideoUpList$Type extends MessageType{constructor(){super("CardVideoUpList",[{no:1,name:"title",kind:"scalar",T:9}])}create(value){const message={title:""};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.title=reader.string();break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.title!=="")writer.tag(1,WireType.LengthDelimited).string(message.title);let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const CardVideoUpList=new CardVideoUpList$Type;class TopicList$Type extends MessageType{constructor(){super("TopicList",[{no:1,name:"title",kind:"scalar",T:9}])}create(value){const message={title:""};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.title=reader.string();break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.title!=="")writer.tag(1,WireType.LengthDelimited).string(message.title);let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const TopicList=new TopicList$Type;class DynamicItem$Type extends MessageType{constructor(){super("DynamicItem",[{no:1,name:"card_type",kind:"enum",T:()=>["DynamicType",DynamicType]}])}create(value){const message={cardType:0};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.cardType=reader.int32();break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.cardType!==0)writer.tag(1,WireType.Varint).int32(message.cardType);let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const DynamicItem=new DynamicItem$Type;switch(PATHs?.[1]){case"DynAll":data=DynAllReply.fromBinary(body);switch(Settings?.Detail?.Hot_topics){case true:default:$.log(`🎉 动态综合页热门话题去除`);delete data.topicList;break;case false:$.log(`🚧 用户设置动态综合页热门话题不去除`);break}switch(Settings?.Detail?.Most_visited){case true:default:$.log(`🎉 动态综合页最常访问去除`);delete data.upList;break;case false:$.log(`🚧 用户设置动态综合页最常访问不去除`);break}switch(Settings?.Detail?.Dynamic_adcard){case true:default:if(data.dynamicList?.list?.length){data.dynamicList.list=data.dynamicList.list.filter(item=>{if(item.cardType===15){$.log(`🎉 动态综合页广告动态去除`);return false}else return true})}break;case false:$.log(`🚧 用户设置动态综合页广告动态不去除`);break}body=DynAllReply.toBinary(data);break;case"DynVideo":data=DynVideoReply.fromBinary(body);switch(Settings?.Detail?.Most_visited){case true:default:$.log(`🎉 动态视频页最常访问去除`);delete data.videoUpList;break;case false:$.log(`🚧 用户设置动态视频页最常访问不去除`);break}body=DynVideoReply.toBinary(data);break}break;case"bilibili.app.view.v1.View":switch(PATHs?.[1]){case"View":class ViewReply$Type extends MessageType{constructor(){super("ViewReply",[{no:6,name:"t_icon",kind:"map",K:9,V:{kind:"message",T:()=>TIcon}},{no:10,name:"relates",kind:"message",repeat:1,T:()=>Relate},{no:30,name:"cms",kind:"message",repeat:1,T:()=>CM},{no:31,name:"cm_config",kind:"message",T:()=>CMConfig},{no:41,name:"cm_ipad",kind:"message",T:()=>CmIpad}])}create(value){const message={tIcon:{},relates:[],cms:[]};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 6:this.binaryReadMap6(message.tIcon,reader,options);break;case 10:message.relates.push(Relate.internalBinaryRead(reader,reader.uint32(),options));break;case 30:message.cms.push(CM.internalBinaryRead(reader,reader.uint32(),options));break;case 31:message.cmConfig=CMConfig.internalBinaryRead(reader,reader.uint32(),options,message.cmConfig);break;case 41:message.cmIpad=CmIpad.internalBinaryRead(reader,reader.uint32(),options,message.cmIpad);break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}binaryReadMap6(map,reader,options){let len=reader.uint32(),end=reader.pos+len,key,val;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:key=reader.string();break;case 2:val=TIcon.internalBinaryRead(reader,reader.uint32(),options);break;default:throw new globalThis.Error("unknown map entry field for field ViewReply.t_icon")}}map[key??""]=val??TIcon.create()}internalBinaryWrite(message,writer,options){for(let k of Object.keys(message.tIcon)){writer.tag(6,WireType.LengthDelimited).fork().tag(1,WireType.LengthDelimited).string(k);writer.tag(2,WireType.LengthDelimited).fork();TIcon.internalBinaryWrite(message.tIcon[k],writer,options);writer.join().join()}for(let i=0;i<message.relates.length;i++)Relate.internalBinaryWrite(message.relates[i],writer.tag(10,WireType.LengthDelimited).fork(),options).join();for(let i=0;i<message.cms.length;i++)CM.internalBinaryWrite(message.cms[i],writer.tag(30,WireType.LengthDelimited).fork(),options).join();if(message.cmConfig)CMConfig.internalBinaryWrite(message.cmConfig,writer.tag(31,WireType.LengthDelimited).fork(),options).join();if(message.cmIpad)CmIpad.internalBinaryWrite(message.cmIpad,writer.tag(41,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const ViewReply=new ViewReply$Type;class CMConfig$Type extends MessageType{constructor(){super("CMConfig",[{no:1,name:"ads_control",kind:"message",T:()=>Any}])}create(value){const message={};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.adsControl=Any.internalBinaryRead(reader,reader.uint32(),options,message.adsControl);break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.adsControl)Any.internalBinaryWrite(message.adsControl,writer.tag(1,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const CMConfig=new CMConfig$Type;class CmIpad$Type extends MessageType{constructor(){super("CmIpad",[{no:5,name:"aid",kind:"scalar",T:3,L:0}])}create(value){const message={aid:0n};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 5:message.aid=reader.int64().toBigInt();break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.aid!==0n)writer.tag(5,WireType.Varint).int64(message.aid);let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const CmIpad=new CmIpad$Type;class TIcon$Type extends MessageType{constructor(){super("TIcon",[{no:1,name:"icon",kind:"scalar",T:9}])}create(value){const message={icon:""};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.icon=reader.string();break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.icon!=="")writer.tag(1,WireType.LengthDelimited).string(message.icon);let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const TIcon=new TIcon$Type;class Relate$Type extends MessageType{constructor(){super("Relate",[{no:28,name:"cm",kind:"message",T:()=>CM}])}create(value){const message={};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 28:message.cm=CM.internalBinaryRead(reader,reader.uint32(),options,message.cm);break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.cm)CM.internalBinaryWrite(message.cm,writer.tag(28,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const Relate=new Relate$Type;switch(Settings?.Detail?.view){case true:default:let data=ViewReply.fromBinary(body);if(data.cms?.length){$.log(`🎉 播放页广告卡片去除`);data.cms=[]}if(data.relates?.length){data.relates=data.relates.filter(item=>{if(item.cm){$.log(`🎉 播放页关联推荐广告去除`);return false}return true})}if(data.cmConfig||data.cmIpad){$.log(`🎉 播放页定制tab去除`);delete data.cmConfig;delete data.cmIpad}for(const i in data.tIcon){if(data.tIcon[i]===null){delete data.tIcon[i]}}body=ViewReply.toBinary(data);break;case false:$.log(`🚧 用户设置播放页广告不去除`);break}break;case"TFInfo":class TFInfoReply$Type extends MessageType{constructor(){super("TFInfoReply",[{no:1,name:"tipsId",kind:"scalar",T:3,L:0},{no:2,name:"tfToast",kind:"message",T:()=>TFToast},{no:3,name:"tfPanelCustomized",kind:"message",T:()=>TFPanelCustomized}])}create(value){const message={tipsId:0n};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.tipsId=reader.int64().toBigInt();break;case 2:message.tfToast=TFToast.internalBinaryRead(reader,reader.uint32(),options,message.tfToast);break;case 3:message.tfPanelCustomized=TFPanelCustomized.internalBinaryRead(reader,reader.uint32(),options,message.tfPanelCustomized);break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.tipsId!==0n)writer.tag(1,WireType.Varint).int64(message.tipsId);if(message.tfToast)TFToast.internalBinaryWrite(message.tfToast,writer.tag(2,WireType.LengthDelimited).fork(),options).join();if(message.tfPanelCustomized)TFPanelCustomized.internalBinaryWrite(message.tfPanelCustomized,writer.tag(3,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const TFInfoReply=new TFInfoReply$Type;class TFToast$Type extends MessageType{constructor(){super("TFToast",[{no:1,name:"btnText",kind:"scalar",T:9}])}create(value){const message={btnText:""};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.btnText=reader.string();break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.btnText!=="")writer.tag(1,WireType.LengthDelimited).string(message.btnText);let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const TFToast=new TFToast$Type;class TFPanelCustomized$Type extends MessageType{constructor(){super("TFPanelCustomized",[{no:2,name:"rightBtnText",kind:"scalar",T:9}])}create(value){const message={rightBtnText:""};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 2:message.rightBtnText=reader.string();break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.rightBtnText!=="")writer.tag(2,WireType.LengthDelimited).string(message.rightBtnText);let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const TFPanelCustomized=new TFPanelCustomized$Type;let data=TFInfoReply.fromBinary(body);$.log(data.tipsId);if(data?.tipsId){$.log(`🎉 播放页办卡免流广告去除`);delete data.tfToast;delete data.tfPanelCustomized}body=TFInfoReply.toBinary(data);break}break;case"bilibili.app.viewunite.v1.View":class ViewReply$Type extends MessageType{constructor(){super("bilibili.app.viewunite.v1.ViewReply",[{no:5,name:"tab",kind:"message",T:()=>Tab},{no:7,name:"cm",kind:"message",T:()=>CM}])}create(value){const message={};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 5:message.tab=Tab.internalBinaryRead(reader,reader.uint32(),options,message.tab);break;case 7:message.cm=CM.internalBinaryRead(reader,reader.uint32(),options,message.cm);break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.tab)Tab.internalBinaryWrite(message.tab,writer.tag(5,WireType.LengthDelimited).fork(),options).join();if(message.cm)CM.internalBinaryWrite(message.cm,writer.tag(7,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const ViewReply=new ViewReply$Type;class Tab$Type extends MessageType{constructor(){super("bilibili.app.viewunite.v1.Tab",[{no:1,name:"tab_module",kind:"message",repeat:1,T:()=>TabModule}])}create(value){const message={tabModule:[]};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.tabModule.push(TabModule.internalBinaryRead(reader,reader.uint32(),options));break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){for(let i=0;i<message.tabModule.length;i++)TabModule.internalBinaryWrite(message.tabModule[i],writer.tag(1,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const Tab=new Tab$Type;class TabModule$Type extends MessageType{constructor(){super("bilibili.app.viewunite.v1.TabModule",[{no:2,name:"introduction",kind:"message",oneof:"tab",T:()=>IntroductionTab}])}create(value){const message={tab:{oneofKind:undefined}};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 2:message.tab={oneofKind:"introduction",introduction:IntroductionTab.internalBinaryRead(reader,reader.uint32(),options,message.tab.introduction)};break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.tab.oneofKind==="introduction")IntroductionTab.internalBinaryWrite(message.tab.introduction,writer.tag(2,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const TabModule=new TabModule$Type;class IntroductionTab$Type extends MessageType{constructor(){super("bilibili.app.viewunite.v1.IntroductionTab",[{no:2,name:"modules",kind:"message",repeat:1,T:()=>Module}])}create(value){const message={modules:[]};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 2:message.modules.push(Module.internalBinaryRead(reader,reader.uint32(),options));break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){for(let i=0;i<message.modules.length;i++)Module.internalBinaryWrite(message.modules[i],writer.tag(2,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const IntroductionTab=new IntroductionTab$Type;class Module$Type extends MessageType{constructor(){super("bilibili.app.viewunite.v1.Module",[{no:1,name:"type",kind:"scalar",T:5},{no:22,name:"relates",kind:"message",oneof:"data",T:()=>Relates}])}create(value){const message={type:0,data:{oneofKind:undefined}};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.type=reader.int32();break;case 22:message.data={oneofKind:"relates",relates:Relates.internalBinaryRead(reader,reader.uint32(),options,message.data.relates)};break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.type!==0)writer.tag(1,WireType.Varint).int32(message.type);if(message.data.oneofKind==="relates")Relates.internalBinaryWrite(message.data.relates,writer.tag(22,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const Module=new Module$Type;class Relates$Type extends MessageType{constructor(){super("bilibili.app.viewunite.v1.Relates",[{no:1,name:"cards",kind:"message",repeat:1,T:()=>RelateCard}])}create(value){const message={cards:[]};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.cards.push(RelateCard.internalBinaryRead(reader,reader.uint32(),options));break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){for(let i=0;i<message.cards.length;i++)RelateCard.internalBinaryWrite(message.cards[i],writer.tag(1,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const Relates=new Relates$Type;class RelateCard$Type extends MessageType{constructor(){super("bilibili.app.viewunite.v1.RelateCard",[{no:1,name:"relate_card_type",kind:"scalar",T:5}])}create(value){const message={relateCardType:0};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.relateCardType=reader.int32();break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.relateCardType!==0)writer.tag(1,WireType.Varint).int32(message.relateCardType);let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const RelateCard=new RelateCard$Type;class RelatesFeedReply$Type extends MessageType{constructor(){super("bilibili.app.viewunite.v1.RelatesFeedReply",[{no:1,name:"relates",kind:"message",repeat:1,T:()=>RelateCard}])}create(value){const message={relates:[]};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.relates.push(RelateCard.internalBinaryRead(reader,reader.uint32(),options));break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){for(let i=0;i<message.relates.length;i++)RelateCard.internalBinaryWrite(message.relates[i],writer.tag(1,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const RelatesFeedReply=new RelatesFeedReply$Type;switch(PATHs?.[1]){case"View":switch(Settings?.Detail?.view){case true:default:let data=ViewReply.fromBinary(body);if(data.cm?.sourceContent?.length){$.log(`🎉 up主推荐广告去除`);data.cm.sourceContent=[]}data.tab.tabModule[0].tab.introduction.modules=data.tab.tabModule[0].tab.introduction.modules.map(i=>{if(i.type===28){$.log(`🎉 视频详情下方推荐卡广告去除`);i.data.relates.cards=i.data.relates.cards.filter(j=>j.relateCardType!==5&&j.relateCardType!==4)}return i});body=ViewReply.toBinary(data);break;case false:$.log(`🚧 用户设置up主推荐广告不去除`);break}break;case"RelatesFeed":try{let data=RelatesFeedReply.fromBinary(body);data.relates=data.relates.filter(item=>{if(item.relateCardType==5){$.log("Remove RelatesFeed CM ads");return false}return true});body=RelatesFeedReply.toBinary(data)}catch(error){$.log(error.stack)}break}break;case"bilibili.app.interface.v1.Teenagers":switch(PATHs?.[1]){case"ModeStatus":class ModeStatus$Type extends MessageType{constructor(){super("ModeStatus",[{no:1,name:"modes",kind:"message",repeat:1,T:()=>Mode}])}create(value){const message={modes:[]};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.modes.push(Mode.internalBinaryRead(reader,reader.uint32(),options));break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){for(let i=0;i<message.modes.length;i++)Mode.internalBinaryWrite(message.modes[i],writer.tag(1,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const ModeStatus=new ModeStatus$Type;class Mode$Type extends MessageType{constructor(){super("Mode",[{no:2,name:"name",kind:"scalar",T:9},{no:5,name:"f5",kind:"message",T:()=>F5}])}create(value){const message={name:""};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 2:message.name=reader.string();break;case 5:message.f5=F5.internalBinaryRead(reader,reader.uint32(),options,message.f5);break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.name!=="")writer.tag(2,WireType.LengthDelimited).string(message.name);if(message.f5)F5.internalBinaryWrite(message.f5,writer.tag(5,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const Mode=new Mode$Type;class F5$Type extends MessageType{constructor(){super("F5",[{no:1,name:"f1",kind:"scalar",T:5}])}create(value){const message={f1:0};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.f1=reader.int32();break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.f1!==0)writer.tag(1,WireType.Varint).int32(message.f1);let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const F5=new F5$Type;data=ModeStatus.fromBinary(body);data.modes=data.modes.map(mode=>{if(mode?.name==="teenagers"){if(mode?.f5?.f1){mode.f5.f1=0;$.log(`🎉 青少年模式弹窗去除`)}}return mode});body=ModeStatus.toBinary(data);break}break;case"bilibili.community.service.dm.v1.DM":class CommandDm$Type extends MessageType{constructor(){super("CommandDm",[{no:1,name:"id",kind:"scalar",T:3,L:0}])}create(value){const message={id:0n};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.id=reader.int64().toBigInt();break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.id!==0n)writer.tag(1,WireType.Varint).int64(message.id);let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const CommandDm=new CommandDm$Type;class DmView$Type extends MessageType{constructor(){super("DmView",[{no:1,name:"commandDms",kind:"message",repeat:1,T:()=>CommandDm}])}create(value){const message={commandDms:[]};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.commandDms.push(CommandDm.internalBinaryRead(reader,reader.uint32(),options));break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){for(let i=0;i<message.commandDms.length;i++)CommandDm.internalBinaryWrite(message.commandDms[i],writer.tag(1,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const DmView=new DmView$Type;class DmViewReply$Type extends MessageType{constructor(){super("DmViewReply",[{no:22,name:"dmView",kind:"message",T:()=>DmView},{no:18,name:"activity_meta",kind:"scalar",repeat:2,T:9}])}create(value){const message={activityMeta:[]};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 22:message.dmView=DmView.internalBinaryRead(reader,reader.uint32(),options,message.dmView);break;case 18:message.activityMeta.push(reader.string());break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.dmView)DmView.internalBinaryWrite(message.dmView,writer.tag(22,WireType.LengthDelimited).fork(),options).join();for(let i=0;i<message.activityMeta.length;i++)writer.tag(18,WireType.LengthDelimited).string(message.activityMeta[i]);let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const DmViewReply=new DmViewReply$Type;class DmSegMobileReply$Type extends MessageType{constructor(){super("DmSegMobileReply",[{no:1,name:"elems",kind:"message",repeat:1,T:()=>DanmakuElem}])}create(value){const message={elems:[]};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.elems.push(DanmakuElem.internalBinaryRead(reader,reader.uint32(),options));break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){for(let i=0;i<message.elems.length;i++)DanmakuElem.internalBinaryWrite(message.elems[i],writer.tag(1,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const DmSegMobileReply=new DmSegMobileReply$Type;class DanmakuElem$Type extends MessageType{constructor(){super("DanmakuElem",[{no:24,name:"colorful",kind:"scalar",T:5}])}create(value){const message={colorful:0};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 24:message.colorful=reader.int32();break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.colorful!==0)writer.tag(24,WireType.Varint).int32(message.colorful);let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const DanmakuElem=new DanmakuElem$Type;switch(PATHs?.[1]){case"DmView":switch(Settings?.Detail?.commandDms){case true:let data=DmViewReply.fromBinary(body);if(data.dmView?.commandDms?.length){$.log(`🎉 交互式弹幕去除`);data.dmView.commandDms.length=0}if(data.activityMeta.length){$.log(`🎉 雲視聽水印去除`);data.activityMeta=[]}body=DmViewReply.toBinary(data);break;case false:default:$.log(`🎉 用户设置交互式弹幕不去除`);break}break;case"DmSegMobile":switch(Settings?.Detail?.colorfulDms){case true:let data=DmSegMobileReply.fromBinary(body);data.elems=data.elems.map(ele=>{if(ele?.colorful===60001){ele.colorful=0}return ele});$.log(`🎉 会员弹幕已替换为普通弹幕`);body=DmSegMobileReply.toBinary(data);break;case false:default:$.log(`🎉 用户设置会员弹幕不修改`);break}break}break;case"bilibili.main.community.reply.v1.Reply":switch(PATHs?.[1]){case"MainList":class MainListReply$Type extends MessageType{constructor(){super("MainListReply",[{no:11,name:"cm",kind:"message",T:()=>CM}])}create(value){const message={};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 11:message.cm=CM.internalBinaryRead(reader,reader.uint32(),options,message.cm);break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.cm)CM.internalBinaryWrite(message.cm,writer.tag(11,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const MainListReply=new MainListReply$Type;switch(Settings?.Detail?.MainList){case true:default:try{let data=MainListReply.fromBinary(body);$.log(`🎉 评论列表广告去除`);delete data.cm;body=MainListReply.toBinary(data);break}catch(error){console.log(error)}case false:$.log(`🎉 用户设置评论列表广告不去除`);break}break}break;case"bilibili.pgc.gateway.player.v2.PlayURL":switch(PATHs?.[1]){}break;case"bilibili.app.nativeact.v1.NativeAct":switch(PATHs?.[1]){}break;case"bilibili.app.interface.v1.Search":switch(PATHs?.[1]){case"DefaultWords":class DefaultWordsReply$Type extends MessageType{constructor(){super("bilibili.app.interface.v1.DefaultWordsReply",[{no:3,name:"show",kind:"scalar",T:9},{no:4,name:"word",kind:"scalar",T:9}])}create(value){const message=globalThis.Object.create(this.messagePrototype);message.show="";message.word="";if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 3:message.show=reader.string();break;case 4:message.word=reader.string();break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.show!=="")writer.tag(3,WireType.LengthDelimited).string(message.show);if(message.word!=="")writer.tag(4,WireType.LengthDelimited).string(message.word);let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const DefaultWordsReply=new DefaultWordsReply$Type;let data=DefaultWordsReply.fromBinary(body);$.log(`🎉 移除 DefaultWord`);data.show="";data.word="";body=DefaultWordsReply.toBinary(data);break}break;case"bilibili.polymer.app.search.v1.Search":switch(PATHs?.[1]){case"SearchAll":{class Item$Type extends MessageType{constructor(){super("bilibili.polymer.app.search.v1.Item",[{no:11,name:"game",kind:"message",oneof:"cardItem",T:()=>SearchGameCard},{no:25,name:"cm",kind:"message",oneof:"cardItem",T:()=>SearchAdCard}])}create(value){const message={cardItem:{oneofKind:undefined}};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 11:message.cardItem={oneofKind:"game",game:SearchGameCard.internalBinaryRead(reader,reader.uint32(),options,message.cardItem.game)};break;case 25:message.cardItem={oneofKind:"cm",cm:SearchAdCard.internalBinaryRead(reader,reader.uint32(),options,message.cardItem.cm)};break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.cardItem.oneofKind==="game")SearchGameCard.internalBinaryWrite(message.cardItem.game,writer.tag(11,WireType.LengthDelimited).fork(),options).join();if(message.cardItem.oneofKind==="cm")SearchAdCard.internalBinaryWrite(message.cardItem.cm,writer.tag(25,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const Item=new Item$Type;class SearchAdCard$Type extends MessageType{constructor(){super("bilibili.polymer.app.search.v1.SearchAdCard",[{no:1,name:"json_str",kind:"scalar",T:9}])}create(value){const message={jsonStr:""};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.jsonStr=reader.string();break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.jsonStr!=="")writer.tag(1,WireType.LengthDelimited).string(message.jsonStr);let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const SearchAdCard=new SearchAdCard$Type;class SearchGameCard$Type extends MessageType{constructor(){super("bilibili.polymer.app.search.v1.SearchGameCard",[{no:1,name:"title",kind:"scalar",T:9}])}create(value){const message={title:""};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 1:message.title=reader.string();break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){if(message.title!=="")writer.tag(1,WireType.LengthDelimited).string(message.title);let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const SearchGameCard=new SearchGameCard$Type;class SearchAllResponse$Type extends MessageType{constructor(){super("bilibili.polymer.app.search.v1.SearchAllResponse",[{no:4,name:"item",kind:"message",repeat:1,T:()=>Item}])}create(value){const message={item:[]};globalThis.Object.defineProperty(message,MESSAGE_TYPE,{enumerable:false,value:this});if(value!==undefined)reflectionMergePartial(this,message,value);return message}internalBinaryRead(reader,length,options,target){let message=target??this.create(),end=reader.pos+length;while(reader.pos<end){let[fieldNo,wireType]=reader.tag();switch(fieldNo){case 4:message.item.push(Item.internalBinaryRead(reader,reader.uint32(),options));break;default:let u=options.readUnknownField;if(u==="throw")throw new globalThis.Error(`Unknown field ${fieldNo}(wire type ${wireType})for ${this.typeName}`);let d=reader.skip(wireType);if(u!==false)(u===true?UnknownFieldHandler.onRead:u)(this.typeName,message,fieldNo,wireType,d)}}return message}internalBinaryWrite(message,writer,options){for(let i=0;i<message.item.length;i++)Item.internalBinaryWrite(message.item[i],writer.tag(4,WireType.LengthDelimited).fork(),options).join();let u=options.writeUnknownFields;if(u!==false)(u==true?UnknownFieldHandler.onWrite:u)(this.typeName,message,writer);return writer}}const SearchAllResponse=new SearchAllResponse$Type;switch(Settings?.Detail?.search){case true:default:let data=SearchAllResponse.fromBinary(body);$.log(`🎉 搜索页广告去除`);data.item=data.item.filter(i=>!(i.cardItem?.oneofKind==="cm"||i.cardItem?.oneofKind==="game"));body=SearchAllResponse.toBinary(data);break;case false:$.log(`🚧 用户设置搜索页广告不去除`);break}break}}break}break}rawBody=addgRPCHeader({header:header,body:body});break}$response.body=rawBody;break}break;case false:break}})()["catch"](e=>$.logErr(e))["finally"](()=>$.done($response));